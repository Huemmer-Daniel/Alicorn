<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantities · Alicorn.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Alicorn.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Alicorn.jl logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/basic_usage/">Basic Usage</a></li><li><a class="tocitem" href="../../manual/advanced_usage/">Advanced Usage</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../units/">Units</a></li><li><a class="tocitem" href="../dimensions/">Dimensions</a></li><li class="is-active"><a class="tocitem" href>Quantities</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#InternalUnits"><span>InternalUnits</span></a></li><li><a class="tocitem" href="#Scalar-Quantities"><span>Scalar Quantities</span></a></li><li><a class="tocitem" href="#Array-Quantities"><span>Array Quantities</span></a></li><li><a class="tocitem" href="#Array-Methods"><span>Array Methods</span></a></li><li><a class="tocitem" href="#Mathematics"><span>Mathematics</span></a></li><li><a class="tocitem" href="#Broadcasting"><span>Broadcasting</span></a></li></ul></li><li><a class="tocitem" href="../">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Quantities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quantities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Huemmer-Daniel/Alicorn/blob/master/docs/src/reference/quantities.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantities"><a class="docs-heading-anchor" href="#Quantities">Quantities</a><a id="Quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Quantities" title="Permalink"></a></h1><p>The <code>Quantities</code> submodule is concerned with defining and manipulating physical quantities.</p><p>Unless stated otherwise, all types, functions, and constants defined in the submodule are exported to the global scope.</p><h4 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h4><ul><li><a href="#Quantities">Quantities</a></li><ul><li><a href="#Overview">Overview</a></li><ul><li><a href="#Types-Representing-Quantities">Types Representing Quantities</a></li><li><a href="#Type-Aliases">Type Aliases</a></li></ul><li><a href="#InternalUnits">InternalUnits</a></li><li><a href="#Scalar-Quantities">Scalar Quantities</a></li><ul><li><a href="#Types">Types</a></li><li><a href="#Construction">Construction</a></li><li><a href="#Dimension">Dimension</a></li><li><a href="#Type-conversion">Type conversion</a></li><li><a href="#Unit-Conversion">Unit Conversion</a></li></ul><li><a href="#Array-Quantities">Array Quantities</a></li><ul><li><a href="#Types-2">Types</a></li><li><a href="#Construction-2">Construction</a></li><li><a href="#Dimension-2">Dimension</a></li><li><a href="#Type-Conversion">Type Conversion</a></li><li><a href="#Unit-Conversion-2">Unit Conversion</a></li></ul><li><a href="#Array-Methods">Array Methods</a></li><li><a href="#Mathematics">Mathematics</a></li><ul><li><a href="#Arithmetics">Arithmetics</a></li><li><a href="#Numeric-Comparison">Numeric Comparison</a></li><li><a href="#Sign-and-Absolute-Value">Sign and Absolute Value</a></li><li><a href="#Roots">Roots</a></li><li><a href="#Complex-Numbers">Complex Numbers</a></li></ul><li><a href="#Broadcasting">Broadcasting</a></li></ul></ul><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Alicorn distinguishes scalar (number-valued) and array (vector-, matrix-, or tensor-valued) quantities. The abstract supertype for all scalar quantities is <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a>, while the abstract supertype for all array quantities is <a href="#Alicorn.Quantities.AbstractQuantityArray"><code>AbstractQuantityArray</code></a>. <code>AbstractQuantityArray</code> is a subtype of <code>Base.AbstractArray</code> and implements its interface.</p><h3 id="Types-Representing-Quantities"><a class="docs-heading-anchor" href="#Types-Representing-Quantities">Types Representing Quantities</a><a id="Types-Representing-Quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Types-Representing-Quantities" title="Permalink"></a></h3><p>There are two concrete implementations of each supertype:</p><ul><li><a href="#Alicorn.Quantities.SimpleQuantity"><code>SimpleQuantity</code></a> and <a href="#Alicorn.Quantities.Quantity"><code>Quantity</code></a> for scalar quantities, and</li><li><a href="#Alicorn.Quantities.SimpleQuantityArray"><code>SimpleQuantityArray</code></a> and <a href="#Alicorn.Quantities.QuantityArray"><code>QuantityArray</code></a> for array quantities.</li></ul><p>The type graph for physical quantities is</p><pre><code class="language-none">AbstractQuantity{T}
├─ SimpleQuantity{T}
└─ Quantity{T}

AbstractQuantityArray{T,N} &lt;: AbstractArray{T,N}
├─ SimpleQuantityArray{T,N}
└─ QuantityArray{T,N}</code></pre><p>The <code>SimpleQuantity</code> and <code>SimpleQuantityArray</code> types store their numerical values expressed directly with respect to their unit.</p><p>The <code>Quantity</code> and <code>QuantityArray</code> types store their numerical values expressed with respect to a shared set of internal units for the seven basic physical dimensions of the SI system. These internal units are represented by a <a href="#Alicorn.Quantities.InternalUnits"><code>InternalUnits</code></a> object. Instead of a concrete units for each quantity, only their physical dimension is retained. This approach can reduce the need for unit conversions during calculations. Moreover, it facilitates the use of a global set of internal units adapted to the magnitudes of the quantities appearing in a given calculation.</p><h3 id="Type-Aliases"><a class="docs-heading-anchor" href="#Type-Aliases">Type Aliases</a><a id="Type-Aliases-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Aliases" title="Permalink"></a></h3><p>Alicorn defines the following aliases for one- and two-dimensional arrays:</p><table><tr><th style="text-align: left">Type name</th><th style="text-align: center">Mathematical dimension</th><th style="text-align: center">Role</th><th style="text-align: center">Alias for</th><th style="text-align: center">Carries physical dimension</th></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity{T}</code></a></td><td style="text-align: center">N=0</td><td style="text-align: center">abstract supertype</td><td style="text-align: center">-</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.AbstractQuantityVector"><code>AbstractQuantityVector{T}</code></a></td><td style="text-align: center">N=1</td><td style="text-align: center">abstract supertype</td><td style="text-align: center"><code>AbstractQuantityArray{T,1}</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.AbstractQuantityMatrix"><code>AbstractQuantityMatrix{T}</code></a></td><td style="text-align: center">N=2</td><td style="text-align: center">abstract supertype</td><td style="text-align: center"><code>AbstractQuantityArray{T,2}</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.AbstractQuantityArray"><code>AbstractQuantityArray{T,N}</code></a></td><td style="text-align: center">N</td><td style="text-align: center">abstract supertype</td><td style="text-align: center">-</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.SimpleQuantity"><code>SimpleQuantity{T}</code></a></td><td style="text-align: center">N=0</td><td style="text-align: center">concrete type</td><td style="text-align: center">-</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.SimpleQuantityVector"><code>SimpleQuantityVector{T}</code></a></td><td style="text-align: center">N=1</td><td style="text-align: center">concrete type</td><td style="text-align: center"><code>SimpleQuantityArray{T,1}</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.SimpleQuantityMatrix"><code>SimpleQuantityMatrix{T}</code></a></td><td style="text-align: center">N=2</td><td style="text-align: center">concrete type</td><td style="text-align: center"><code>SimpleQuantityArray{T,2}</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.SimpleQuantityArray"><code>SimpleQuantityArray{T,N}</code></a></td><td style="text-align: center">N</td><td style="text-align: center">concrete type</td><td style="text-align: center">-</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.Quantity"><code>Quantity{T}</code></a></td><td style="text-align: center">N=0</td><td style="text-align: center">concrete type</td><td style="text-align: center">-</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.QuantityVector"><code>QuantityVector{T}</code></a></td><td style="text-align: center">N=1</td><td style="text-align: center">concrete type</td><td style="text-align: center"><code>QuantityArray{T,1}</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.QuantityMatrix"><code>QuantityMatrix{T}</code></a></td><td style="text-align: center">N=2</td><td style="text-align: center">concrete type</td><td style="text-align: center"><code>QuantityArray{T,2}</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.QuantityArray"><code>QuantityArray{T,N}</code></a></td><td style="text-align: center">N</td><td style="text-align: center">concrete type</td><td style="text-align: center">-</td><td style="text-align: center">yes</td></tr></table><p>Type unions for scalar and array quantities of the same kind:</p><table><tr><th style="text-align: left">Type name</th><th style="text-align: center">Role</th><th style="text-align: center">Alias for</th><th style="text-align: center">Carries physical dimension</th></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType{T}</code></a></td><td style="text-align: center">type union</td><td style="text-align: center"><code>Union{AbstractQuantity{T}, AbstractQuantityArray{T}} where T&lt;:Number</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.SimpleQuantityType"><code>SimpleQuantityType{T}</code></a></td><td style="text-align: center">type union</td><td style="text-align: center"><code>Union{SimpleQuantity{T}, SimpleQuantityArray{T}} where T&lt;:Number</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.QuantityType"><code>QuantityType{T}</code></a></td><td style="text-align: center">type union</td><td style="text-align: center"><code>Union{Quantity{T}, QuantityArray{T}} where T&lt;:Number</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.DimensionlessType"><code>DimensionlessType{T}</code></a></td><td style="text-align: center">type union</td><td style="text-align: center"><code>Union{Number, AbstractArray{&lt;:Number}} where T&lt;:Number</code></td><td style="text-align: center">no</td></tr></table><p>Type unions for scalar and array quantities:</p><table><tr><th style="text-align: left">Type name</th><th style="text-align: center">Mathematical dimension</th><th style="text-align: center">Role</th><th style="text-align: center">Alias for</th><th style="text-align: center">Carries physical dimension</th></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.ScalarQuantity"><code>ScalarQuantity{T}</code></a></td><td style="text-align: center">N=0</td><td style="text-align: center">type union</td><td style="text-align: center"><code>Union{T, AbstractQuantity{T}} where T&lt;:Number</code></td><td style="text-align: center">either yes or no</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.VectorQuantity"><code>VectorQuantity{T}</code></a></td><td style="text-align: center">N=1</td><td style="text-align: center">type union</td><td style="text-align: center"><code>Union{T, AbstractQuantityVector{T}} where T&lt;:Number</code></td><td style="text-align: center">either yes or no</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.MatrixQuantity"><code>MatrixQuantity{T}</code></a></td><td style="text-align: center">N=2</td><td style="text-align: center">type union</td><td style="text-align: center"><code>Union{T, AbstractQuantityMatrix{T}} where T&lt;:Number</code></td><td style="text-align: center">either yes or no</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.ArrayQuantity"><code>ArrayQuantity{T,N}</code></a></td><td style="text-align: center">N</td><td style="text-align: center">type union</td><td style="text-align: center"><code>Union{Array{T,N}, AbstractQuantityArray{T,N}} where {T&lt;:Number, N}</code></td><td style="text-align: center">either yes or no</td></tr></table><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.AbstractQuantityType" href="#Alicorn.Quantities.AbstractQuantityType"><code>Alicorn.Quantities.AbstractQuantityType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractQuantityType{T}</code></pre><p>Alias for <code>Union{AbstractQuantity{T}, AbstractQuantityArray{T}} where T&lt;:Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/AbstractQuantityArray.jl#L59-L63">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantityType" href="#Alicorn.Quantities.SimpleQuantityType"><code>Alicorn.Quantities.SimpleQuantityType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleQuantityType{T}</code></pre><p>Alias for <code>Union{SimpleQuantity{T}, SimpleQuantityArray{T}} where T&lt;:Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/SimpleQuantityArray.jl#L53-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.QuantityType" href="#Alicorn.Quantities.QuantityType"><code>Alicorn.Quantities.QuantityType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuantityType{T}</code></pre><p>Alias for <code>Union{Quantity{T}, QuantityArray{T}} where T&lt;:Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/QuantityArray.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.DimensionlessType" href="#Alicorn.Quantities.DimensionlessType"><code>Alicorn.Quantities.DimensionlessType</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DimensionlessType{T}</code></pre><p>Type union representing numbers and number arrays.</p><p>Alias for <code>Union{Number, AbstractArray{&lt;:Number}}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/AbstractQuantityArray.jl#L66-L72">source</a></section></article><h2 id="InternalUnits"><a class="docs-heading-anchor" href="#InternalUnits">InternalUnits</a><a id="InternalUnits-1"></a><a class="docs-heading-anchor-permalink" href="#InternalUnits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.InternalUnits" href="#Alicorn.Quantities.InternalUnits"><code>Alicorn.Quantities.InternalUnits</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InternalUnits</code></pre><p>A set of seven <code>SimpleQuantity</code> objects which represent a choice of units with respect to which the seven basic physical dimensions of the SI system are measured.</p><p><strong>Fields</strong></p><ul><li><code>mass::SimpleQuantity</code>: unit of mass</li><li><code>length::SimpleQuantity</code>: unit of length</li><li><code>time::SimpleQuantity</code>: unit of time</li><li><code>current::SimpleQuantity</code>: unit of current</li><li><code>temperature::SimpleQuantity</code>: unit of temperature</li><li><code>amount::SimpleQuantity</code>: unit of amount</li><li><code>luminousIntensity::SimpleQuantity</code>: unit of luminousIntensity</li></ul><p><strong>Constructors</strong></p><pre><code class="language-none">InternalUnits(::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity)
InternalUnits(; mass = 1*kilogram, length = 1*meter, time = 1*second, current = 1*ampere,temperature = 1*kelvin, amount = 1*mol, luminousIntensity = 1*candela)

# Raises Exceptions
- `Core.DomainError`: if attempting to initialize any field with a quantity
of a value that is zero, infinite, or not real
- `Exceptions.DimensionMismatchError`: if attempting to initialize any field
with a quantity whose dimension does not match the physical dimension the field
represents

# Examples
The following `InternalUnits` measure lengths in units of ``3 cm`` and uses
the basic SI units for all other dimensions:</code></pre><p>jldoctest julia&gt; ucat = UnitCatalogue(); cm = ucat.centi * ucat.meter ;</p><p>julia&gt; InternalUnits(length = 3cm) InternalUnits  mass unit:               1 kg  length unit:             3 cm  time unit:               1 s  current unit:            1 A  temperature unit:        1 K  amount unit:             1 mol  luminous intensity unit: 1 cd ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/InternalUnits.jl#L3-L47">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{InternalUnits, InternalUnits}" href="#Base.:==-Tuple{InternalUnits, InternalUnits}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:(==)(internalUnits1::InternalUnits, internalUnits2::InternalUnits)</code></pre><p>Compare two <code>InternalUnits</code> objects.</p><p>Two <code>InternalUnits</code> objects are equal if the <code>SimpleQuantity</code> objects representing the unit for each of the seven physical dimensions are equal.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/InternalUnits.jl#L142-L149">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.internalUnitFor-Tuple{Dimension, InternalUnits}" href="#Alicorn.Quantities.internalUnitFor-Tuple{Dimension, InternalUnits}"><code>Alicorn.Quantities.internalUnitFor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">internalUnitFor(dimension::Dimension, internalUnits::InternalUnits)</code></pre><p>Returns a <code>SimpleQuantity</code> representing the unit in which quantities of physical dimension <code>dimension</code> are measured according to <code>internalUnits</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/InternalUnits.jl#L163-L168">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.conversionFactor-Tuple{Dimension, InternalUnits, InternalUnits}" href="#Alicorn.Quantities.conversionFactor-Tuple{Dimension, InternalUnits, InternalUnits}"><code>Alicorn.Quantities.conversionFactor</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">conversionFactor(dimension::Dimension, currentIntU::InternalUnits, targetIntU::InternalUnits)</code></pre><p>Returns the factor with which a value of physical dimension <code>dimension</code> expressed in units of <code>currentIntU</code> needs to be mutliplied in order to express it in units of <code>targetIntU</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/InternalUnits.jl#L190-L196">source</a></section></article><h2 id="Scalar-Quantities"><a class="docs-heading-anchor" href="#Scalar-Quantities">Scalar Quantities</a><a id="Scalar-Quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-Quantities" title="Permalink"></a></h2><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.AbstractQuantity" href="#Alicorn.Quantities.AbstractQuantity"><code>Alicorn.Quantities.AbstractQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractQuantity{T&lt;:Number}</code></pre><p>Abstract supertype for all quantities that have a scalar value (number) of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/AbstractQuantity.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantity" href="#Alicorn.Quantities.SimpleQuantity"><code>Alicorn.Quantities.SimpleQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleQuantity{T&lt;:Number} &lt;: AbstractQuantity{T}</code></pre><p>A physical quantity consisting of a scalar value and a physical unit.</p><p><strong>Fields</strong></p><ul><li><code>value::T</code>: value of the quantity</li><li><code>unit::Unit</code>: unit of the quantity</li></ul><p><strong>Constructors</strong></p><pre><code class="language-none">SimpleQuantity(::Number, ::AbstractUnit)
SimpleQuantity(::Number)
SimpleQuantity(::AbstractUnit)</code></pre><p>If no unit is passed to the constructor, <code>unitlessUnit</code> is used by default. If no value is passed to the constructor, the value is set to 1 by default.</p><p>If called with a <code>Quantity</code> as argument, the <code>Quantity</code> is expressed in terms of the units used to store its value internally, see <a href="#Alicorn.Quantities.InternalUnits"><code>InternalUnits</code></a>.</p><pre><code class="language-none">SimpleQuantity(::Quantity)</code></pre><p>If the type <code>T</code> is specified explicitly, Alicorn attempts to convert the <code>value</code> accordingly:</p><pre><code class="language-none">SimpleQuantity{T}(::Number, ::AbstractUnit) where {T&lt;:Number}
SimpleQuantity{T}(::Number) where {T&lt;:Number}
SimpleQuantity{T}(::AbstractUnit) where {T&lt;:Number}</code></pre><p><strong>Examples</strong></p><ol><li><p>The quantity <span>$7\,\mathrm{nm}$</span> (seven nanometers) can be constructed using the constructor method as follows:</p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; nanometer = ucat.nano * ucat.meter
UnitFactor nm

julia&gt; quantity = SimpleQuantity(7, nanometer)
7 nm</code></pre></li><li><p>Alternatively, <span>$7\,\mathrm{nm}$</span> can be constructed arithmetically:</p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; nm = ucat.nano * ucat.meter
UnitFactor nm

julia&gt; quantity = 7nm
7 nm</code></pre></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/SimpleQuantity.jl#L1-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.Quantity" href="#Alicorn.Quantities.Quantity"><code>Alicorn.Quantities.Quantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Quantity{T&lt;:Number} &lt;: AbstractQuantity{T}</code></pre><p>A physical quantity consisting of a number, a <code>Dimension</code> object representing the physical dimension, and an <code>InternalUnits</code> object representing the units with respect to which the seven basic dimensions of the SI system are measured.</p><p>The value field of a <code>Quantity{T}</code> is of type <code>T</code>, which needs to be a subtype of <code>Number</code>.</p><p><strong>Fields</strong></p><ul><li><code>value::T</code>: value of the quantity</li><li><code>dimension::Dimension</code>: physical dimension of the quantity</li><li><code>internalUnits::InternalUnits</code>: set of units with respect to which the seven</li></ul><p>basic dimensions of the SI system are measured.</p><p><strong>Constructors</strong></p><p>The constructors preserve the type <code>T</code> of the value upon conversion to the internal units whenever possible. If no <code>InternalUnits</code> are passed to the constructor, the basic SI units are used by default.</p><p>Construction from value and dimension; if no dimension is passed to the constructor, a dimensionless quantity is constructed by default.</p><pre><code class="language-none">Quantity(::Number, ::Dimension, ::InternalUnits)
Quantity(::Number, ::Dimension)
Quantity(::Number, ::InternalUnits)
Quantity(::Number)</code></pre><p>If the type <code>T</code> is specified explicitly, Alicorn attempts to convert the <code>value</code> accordingly:</p><pre><code class="language-none">Quantity{T}(::Number, ::Dimension, ::InternalUnits) where {T&lt;:Number}
Quantity{T}(::Number, ::Dimension) where {T&lt;:Number}
Quantity{T}(::Number, ::InternalUnits) where {T&lt;:Number}
Quantity{T}(::Number) where {T&lt;:Number}</code></pre><p>Construction from value and unit; if no unit is passed to the constructor, a dimensionless quantity is constructed by default.</p><pre><code class="language-none">Quantity(::Number, ::AbstractUnit, ::InternalUnits)
Quantity(::Number, ::AbstractUnit)
Quantity(::AbstractUnit, ::InternalUnits)
Quantity(::AbstractUnit)</code></pre><p><strong>Examples</strong></p><ol><li><p>The quantity <span>$7\,\mathrm{nm}$</span> (seven nanometers) can for instance be constructed as follows:</p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;
       nm = ucat.nano*ucat.meter;
       intu = InternalUnits(length=1nm) ;

julia&gt; Quantity(7nm, intu)
Quantity{Int64} of dimension L^1 in units of (1 nm):
 7</code></pre><p>Note that the original type <code>Int64</code> of the value is preserved.</p></li><li><p>If we use <span>$2\,\mathrm{nm}$</span> as internal unit for length, the value can no longer be represented as type <code>Int64</code> internally:</p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;
       nm = ucat.nano*ucat.meter;
       intu = InternalUnits(length=2nm) ;

julia&gt; Quantity(7nm, intu)
Quantity{Float64} of dimension L^1 in units of (2 nm):
 3.5</code></pre></li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/Quantity.jl#L1-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.ScalarQuantity" href="#Alicorn.Quantities.ScalarQuantity"><code>Alicorn.Quantities.ScalarQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarQuantity{T}</code></pre><p>Type union representing a scalar (number) of type <code>T</code>, with or without a unit.</p><p>Alias for <code>Union{T, AbstractQuantity{T}} where T&lt;:Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/AbstractQuantity.jl#L9-L15">source</a></section></article><h3 id="Construction"><a class="docs-heading-anchor" href="#Construction">Construction</a><a id="Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Construction" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Number, AbstractUnit}" href="#Base.:*-Tuple{Number, AbstractUnit}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(value::Number, abstractUnit::AbstractUnit)</code></pre><p>Combine <code>value</code> and <code>abstractUnit</code> to form a physical quantity of type <code>SimpleQuantity</code>.</p><p>If <code>abstractUnit</code> is a product of a <code>UnitPrefix</code> and <code>BaseUnit</code>, they are first combined into a <code>SimpleQuantity</code>, which is then in turn combined with <code>value</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; 3.5 * ucat.milli * ucat.tesla
3.5 mT</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/SimpleQuantity.jl#L79-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{Number, AbstractUnit}" href="#Base.:/-Tuple{Number, AbstractUnit}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(value::Number, abstractUnit::AbstractUnit)</code></pre><p>Combine <code>value</code> and <code>abstractUnit</code> to form a physical quantity of type <code>SimpleQuantity</code>.</p><p>If <code>abstractUnit</code> is a product of a <code>UnitPrefix</code> and <code>BaseUnit</code>, they are first combined into a <code>SimpleQuantity</code>, which is then in turn combined with <code>value</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; 3.5 / ucat.nano * ucat.second
3.5 ns^-1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/SimpleQuantity.jl#L99-L114">source</a></section></article><h3 id="Dimension"><a class="docs-heading-anchor" href="#Dimension">Dimension</a><a id="Dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Dimension" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Dimensions.dimensionOf-Tuple{AbstractQuantity}" href="#Alicorn.Dimensions.dimensionOf-Tuple{AbstractQuantity}"><code>Alicorn.Dimensions.dimensionOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dimensionOf(quantity::AbstractQuantity)</code></pre><p>Returns the dimension of a physical quantity of type <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a>.</p><p><strong>Example</strong></p><p>One henry is defined as <span>$1\,\mathrm{H} = 1\,\mathrm{kg}^{1}\,\mathrm{m}^{2}\,\mathrm{s}^{-2}\,\mathrm{A}^{-2}$</span> and is hence of dimension <span>$\mathrm{M}^{1}\,\mathrm{L}^{2}\,\mathrm{T}^{-2}\,\mathrm{I}^{-2}$</span>:</p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; oneHenry = 1 * ucat.henry
1 H
julia&gt; dimensionOf(oneHenry)
Dimension M^1 L^2 T^-2 I^-2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_dimensions.jl#L1-L16">source</a></section></article><h3 id="Type-conversion"><a class="docs-heading-anchor" href="#Type-conversion">Type conversion</a><a id="Type-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Type-conversion" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantity-Tuple{AbstractQuantity}" href="#Alicorn.Quantities.SimpleQuantity-Tuple{AbstractQuantity}"><code>Alicorn.Quantities.SimpleQuantity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SimpleQuantity(quantity::AbstractQuantity)</code></pre><p>Construct a <code>SimpleQuantity</code> from a physical quantity of any implementation of <code>AbstractQuantity</code>.</p><p>If <code>quantity</code> is of type <code>SimpleQuantity</code>, it is returned unchanged. If <code>quantity</code> is of type <code>Quantity</code>, it is expressed in terms of the SI units specified by <code>quantity.InternalUnits</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ; intu = InternalUnits(length=2*ucat.milli*ucat.meter) ;

julia&gt; q = Quantity(4, Dimension(L=1), intu)
Quantity{Int64} of dimension L^1 in units of (2 mm):
 4
julia&gt; sq = SimpleQuantity(q)
8 mm</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L3-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantity-Union{Tuple{AbstractQuantity}, Tuple{T}} where T&lt;:Number" href="#Alicorn.Quantities.SimpleQuantity-Union{Tuple{AbstractQuantity}, Tuple{T}} where T&lt;:Number"><code>Alicorn.Quantities.SimpleQuantity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SimpleQuantity{T}(::AbstractQuantity) where {T&lt;:Number}</code></pre><p>Construct a <code>SimpleQuantity{T}</code> with specified type <code>T</code> from a physical quantity of any implementation of <code>AbstractQuantity</code>.</p><p>See <code>SimpleQuantity(::AbstractQuantity)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L41-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.Quantity-Tuple{AbstractQuantity, InternalUnits}" href="#Alicorn.Quantities.Quantity-Tuple{AbstractQuantity, InternalUnits}"><code>Alicorn.Quantities.Quantity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Quantity(::AbstractQuantity, ::InternalUnits)
Quantity(::AbstractQuantity)</code></pre><p>Construct a <code>Quantity</code> from a physical quantity of any implementation of <code>AbstractQuantity</code>.</p><p>If no <code>InternalUnits</code> are specified, they are constructed using basic SI units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L72-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.Quantity-Union{Tuple{T}, Tuple{AbstractQuantity, InternalUnits}} where T&lt;:Number" href="#Alicorn.Quantities.Quantity-Union{Tuple{T}, Tuple{AbstractQuantity, InternalUnits}} where T&lt;:Number"><code>Alicorn.Quantities.Quantity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Quantity{T}(::AbstractQuantity, ::InternalUnits) where {T&lt;:Number}
Quantity{T}(::AbstractQuantity) where {T&lt;:Number}</code></pre><p>Construct a <code>Quantity{T}</code> with specified type <code>T</code> from a physical quantity of any implementation of <code>AbstractQuantity</code>.</p><p>See <code>Quantity(::AbstractQuantity, ::InternalUnits)</code> for details.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>InexactError</code>: if the internal value of <code>AbstractQuantity</code> cannot be</li></ul><p>represented as type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L106-L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{T}, Tuple{Type{T}, SimpleQuantity}} where T&lt;:SimpleQuantity" href="#Base.convert-Union{Tuple{T}, Tuple{Type{T}, SimpleQuantity}} where T&lt;:SimpleQuantity"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.convert(::Type{T}, simpleQuantity::SimpleQuantity) where {T&lt;:SimpleQuantity}</code></pre><p>Convert <code>simpleQuantity</code> from type <code>SimpleQuantity{S} where S</code> to any subtype <code>T</code> of <code>SimpleQuantity</code></p><p>Allows to convert, for instance, from <code>SimpleQuantity{Float64}</code> to <code>SimpleQuantity{UInt8}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L59-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{T}, Tuple{Type{T}, Quantity}} where T&lt;:Quantity" href="#Base.convert-Union{Tuple{T}, Tuple{Type{T}, Quantity}} where T&lt;:Quantity"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.convert(::Type{T}, quantity::Quantity) where {T&lt;:Quantity}</code></pre><p>Convert <code>quantity</code> from type <code>Quantity{S} where S</code> to any type <code>T</code> of <code>Quantity</code>.</p><p>Allows to convert, for instance, from <code>Quantity{Float64}</code> to <code>Quantity{UInt8}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L141-L148">source</a></section></article><h3 id="Unit-Conversion"><a class="docs-heading-anchor" href="#Unit-Conversion">Unit Conversion</a><a id="Unit-Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-Conversion" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inUnitsOf-Tuple{AbstractQuantity, AbstractUnit}" href="#Alicorn.Quantities.inUnitsOf-Tuple{AbstractQuantity, AbstractUnit}"><code>Alicorn.Quantities.inUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inUnitsOf(quantity::AbstractQuantity, unit::AbstractUnit)::SimpleQuantity</code></pre><p>Express <code>quantity</code> as an object of type <code>SimpleQuantity</code> in terms of the unit specified by <code>unit</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantity</code> and <code>unit</code> do not agree</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unitConversion.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inBasicSIUnits-Tuple{AbstractQuantity}" href="#Alicorn.Quantities.inBasicSIUnits-Tuple{AbstractQuantity}"><code>Alicorn.Quantities.inBasicSIUnits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inBasicSIUnits(quantity::AbstractQuantity)::SimpleQuantity</code></pre><p>Express <code>quantity</code> as an object of type <code>SimpleQuantity</code> using the seven basic SI units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unitConversion.jl#L172-L176">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantity, AbstractUnit}" href="#Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantity, AbstractUnit}"><code>Alicorn.Quantities.valueInUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueInUnitsOf(quantity::AbstractQuantity, unit::AbstractUnit)</code></pre><p>Returns the numerical value of <code>quantity</code> expressed in units of <code>unit</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantity</code> and <code>unit</code> do not agree</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unitConversion.jl#L94-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueInUnitsOf-Union{Tuple{T}, Tuple{AbstractQuantity{T}, SimpleQuantity}} where T" href="#Alicorn.Quantities.valueInUnitsOf-Union{Tuple{T}, Tuple{AbstractQuantity{T}, SimpleQuantity}} where T"><code>Alicorn.Quantities.valueInUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueInUnitsOf(quantity::AbstractQuantity, simpleQuantity::SimpleQuantity)</code></pre><p>Returns the numerical value of <code>quantity</code> expressed in units of <code>simpleQuantity</code>.</p><p>The result is equivalent to <code>valueOfDimensionless(quantity / simpleQuantity)</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantity</code> and <code>simpleQuantity</code> do not agree</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unitConversion.jl#L104-L113">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueOfDimensionless-Tuple{AbstractQuantity}" href="#Alicorn.Quantities.valueOfDimensionless-Tuple{AbstractQuantity}"><code>Alicorn.Quantities.valueOfDimensionless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueOfDimensionless(quantity::AbstractQuantity)</code></pre><p>Strips the unit from a dimensionless quantity and returns its bare value.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>quantity</code> is not dimensionless</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unitConversion.jl#L216-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{AbstractQuantity, AbstractUnit}" href="#Base.:*-Tuple{AbstractQuantity, AbstractUnit}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(quantity::AbstractQuantity, unit::AbstractUnit)
Base.:*(unit::AbstractUnit, quantity::AbstractQuantity)</code></pre><p>Modify the unit of <code>quantity</code> by multiplying it with <code>unit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unit_arithmetics.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{AbstractQuantity, AbstractUnit}" href="#Base.:/-Tuple{AbstractQuantity, AbstractUnit}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(quantity::AbstractQuantity, unit::AbstractUnit)
Base.:/(unit::AbstractUnit, quantity::AbstractQuantity)</code></pre><p>Modify the unit of <code>quantity</code> by dividing it by <code>unit</code>, or vice versa.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unit_arithmetics.jl#L31-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inInternalUnitsOf-Tuple{QuantityArray, InternalUnits}" href="#Alicorn.Quantities.inInternalUnitsOf-Tuple{QuantityArray, InternalUnits}"><code>Alicorn.Quantities.inInternalUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inInternalUnitsOf(qArray::QuantityArray{T}, targetIntU::InternalUnits) where T</code></pre><p>Returns a new <code>QuantityArray</code> corresponding to <code>qArray</code>, but stored using <code>targetIntU</code> as new internal units.</p><p>The value type <code>S</code> of the returned quantity array is identical to <code>T</code>, if possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unitConversion.jl#L159-L167">source</a></section></article><h2 id="Array-Quantities"><a class="docs-heading-anchor" href="#Array-Quantities">Array Quantities</a><a id="Array-Quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Array-Quantities" title="Permalink"></a></h2><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.AbstractQuantityArray" href="#Alicorn.Quantities.AbstractQuantityArray"><code>Alicorn.Quantities.AbstractQuantityArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractQuantity{T,N} &lt;: AbstractArray{T,N}</code></pre><p>Abstract supertype for all array-valued quantities of dimension <code>N</code> and with elements of type <code>T</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/AbstractQuantityArray.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.AbstractQuantityVector" href="#Alicorn.Quantities.AbstractQuantityVector"><code>Alicorn.Quantities.AbstractQuantityVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractQuantityVector{T}</code></pre><p>Abstract supertype for one-dimensional array-valued quantities with elements of type <code>T</code>.</p><p>Alias for <code>AbstractQuantityArray{T,1}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/AbstractQuantityArray.jl#L9-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.AbstractQuantityMatrix" href="#Alicorn.Quantities.AbstractQuantityMatrix"><code>Alicorn.Quantities.AbstractQuantityMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractQuantityMatrix{T}</code></pre><p>Abstract supertype for two-dimensional array-valued quantities with elements of type <code>T</code>.</p><p>Alias for <code>AbstractQuantityArray{T,2}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/AbstractQuantityArray.jl#L19-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantityArray" href="#Alicorn.Quantities.SimpleQuantityArray"><code>Alicorn.Quantities.SimpleQuantityArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleQuantityArray{T&lt;:Number,N} &lt;: AbstractQuantityArray{T,N}</code></pre><p>A physical quantity consisting of a number array and a physical unit.</p><p>The value field of a <code>SimpleQuantityArray{T,N}</code> is of type <code>Array{T,N}</code>. <code>T</code> needs to be a subtype of <code>Number</code>.</p><p><strong>Fields</strong></p><ul><li><code>value::Array{T,N}</code>: value of the quantity</li><li><code>unit::Unit</code>: unit of the quantity</li></ul><p><strong>Constructors</strong></p><pre><code class="language-none">SimpleQuantityArray(::AbstractArray, ::AbstractUnit)
SimpleQuantityArray(::AbstractArray)</code></pre><p>If no unit is passed to the constructor, <code>unitlessUnit</code> is used by default.</p><pre><code class="language-none">SimpleQuantityArray{T}(::AbstractArray, ::AbstractUnit) where {T&lt;:Number}
SimpleQuantityArray{T}(::AbstractArray) where {T&lt;:Number}</code></pre><p>If the type <code>T</code> is specified explicitly, Alicorn attempts to convert the <code>value</code> accordingly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/SimpleQuantityArray.jl#L1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantityVector" href="#Alicorn.Quantities.SimpleQuantityVector"><code>Alicorn.Quantities.SimpleQuantityVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleQuantityVector{T}</code></pre><p>One-dimensional array-valued simple quantity with elements of type <code>T</code>.</p><p>Alias for <code>SimpleQuantityArray{T,1}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/SimpleQuantityArray.jl#L35-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantityMatrix" href="#Alicorn.Quantities.SimpleQuantityMatrix"><code>Alicorn.Quantities.SimpleQuantityMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleQuantityMatrix{T}</code></pre><p>Two-dimensional array-valued simple quantity with elements of type <code>T</code>.</p><p>Alias for <code>SimpleQuantityArray{T,2}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/SimpleQuantityArray.jl#L44-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.QuantityArray" href="#Alicorn.Quantities.QuantityArray"><code>Alicorn.Quantities.QuantityArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuantityArray{T&lt;:Number,N} &lt;: AbstractQuantityArray{T,N}</code></pre><p>A physical quantity consisting of an array, a <code>Dimension</code> object representing the physical dimension, and an <code>InternalUnits</code> object representing the units with respect to which the seven basic dimensions of the SI system are measured.</p><p>The value field of a <code>QuantityArray{T,N}</code> is of type <code>Array{T,N}</code>. <code>T</code> needs to be a subtype of <code>Number</code>.</p><p><strong>Fields</strong></p><ul><li><code>value::Array{T,N}</code>: value of the quantity</li><li><code>dimension::Dimension</code>: physical dimension of the quantity</li><li><code>internalUnits::InternalUnits</code>: set of units with respect to which the seven</li></ul><p>basic dimensions of the SI system are measured.</p><p><strong>Constructors</strong></p><pre><code class="language-none">QuantityArray(::AbstractArray, ::Dimension, ::InternalUnits)
QuantityArray(::AbstractArray, ::Dimension)
QuantityArray(::AbstractArray, ::InternalUnits)
QuantityArray(::AbstractArray)</code></pre><p>If no <code>InternalUnits</code> are passed to the constructor, the basic SI units are used. If no <code>Dimension</code> is passed to the constructor, a dimensionless quantity is constructed.</p><pre><code class="language-none">QuantityArray{T}(::AbstractArray, ::Dimension, ::InternalUnits) where {T&lt;:Number}
QuantityArray{T}(::AbstractArray, ::Dimension) where {T&lt;:Number}
QuantityArray{T}(::AbstractArray, ::InternalUnits) where {T&lt;:Number}
QuantityArray{T}(::AbstractArray) where {T&lt;:Number}</code></pre><p>If the type <code>T</code> is specified explicitly, Alicorn attempts to convert the provided <code>AbstractArray</code> to <code>Array{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/QuantityArray.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.QuantityVector" href="#Alicorn.Quantities.QuantityVector"><code>Alicorn.Quantities.QuantityVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuantityVector{T}</code></pre><p>One-dimensional array-valued quantity with elements of type <code>T</code>.</p><p>Alias for <code>QuantityArray{T,1}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/QuantityArray.jl#L46-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.QuantityMatrix" href="#Alicorn.Quantities.QuantityMatrix"><code>Alicorn.Quantities.QuantityMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuantityMatrix{T}</code></pre><p>Two-dimensional array-valued quantity with elements of type <code>T</code>.</p><p>Alias for <code>QuantityArray{T,2}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/QuantityArray.jl#L55-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.VectorQuantity" href="#Alicorn.Quantities.VectorQuantity"><code>Alicorn.Quantities.VectorQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorQuantity{T}</code></pre><p>Type union representing one-dimensional arrays with elements of type <code>T</code>, with or without a physical unit.</p><p>Alias for <code>Union{Vector{T}, AbstractQuantityArray{T, 1}} where T&lt;:Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/AbstractQuantityArray.jl#L29-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.MatrixQuantity" href="#Alicorn.Quantities.MatrixQuantity"><code>Alicorn.Quantities.MatrixQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MatrixQuantity{T}</code></pre><p>Type union representing two-dimensional arrays with elements of type <code>T</code>, with or without a physical unit.</p><p>Alias for <code>Union{Matrix{T}, AbstractQuantityArray{T, 2}} where T&lt;:Number</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/AbstractQuantityArray.jl#L39-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.ArrayQuantity" href="#Alicorn.Quantities.ArrayQuantity"><code>Alicorn.Quantities.ArrayQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ArrayQuantity{T,N}</code></pre><p>Type union representing <code>N</code>-dimensional arrays with elements of type <code>T</code>, with or without a physical unit.</p><p>Alias for <code>Union{Array{T,N}, AbstractQuantityArray{T,N}} where {T&lt;:Number, N}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/AbstractQuantityArray.jl#L49-L56">source</a></section></article><h3 id="Construction-2"><a class="docs-heading-anchor" href="#Construction-2">Construction</a><a class="docs-heading-anchor-permalink" href="#Construction-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractUnit}} where T&lt;:Number" href="#Base.:*-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractUnit}} where T&lt;:Number"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(value::AbstractArray{T}, abstractUnit::AbstractUnit) where {T&lt;:Number}</code></pre><p>Combine the array <code>value</code> and <code>abstractUnit</code> to form a physical quantity of type <code>SimpleQuantityArray</code>.</p><p>If <code>abstractUnit</code> is a product of a <code>UnitPrefix</code> and <code>BaseUnit</code>, they are first combined into a <code>SimpleQuantity</code>, which is then in turn combined with <code>value</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; [3.5, 4.6] * ucat.milli * ucat.tesla
2-element SimpleQuantityVector{Float64} of unit mT:
 3.5
 4.6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/SimpleQuantityArray.jl#L72-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractUnit}} where T&lt;:Number" href="#Base.:/-Union{Tuple{T}, Tuple{AbstractArray{T}, AbstractUnit}} where T&lt;:Number"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(value::AbstractArray{T}, abstractUnit::AbstractUnit) where {T&lt;:Number}</code></pre><p>Combine the array <code>value</code> and <code>abstractUnit</code> to form a physical quantity of type <code>SimpleQuantityArray</code>.</p><p>If <code>abstractUnit</code> is a product of a <code>UnitPrefix</code> and <code>BaseUnit</code>, they are first combined into a <code>SimpleQuantity</code>, which is then in turn combined with <code>value</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; [3.5, 4.6] / ucat.nano * ucat.second
2-element SimpleQuantityVector{Float64} of unit ns^-1:
 3.5
 4.6</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/SimpleQuantityArray.jl#L94-L111">source</a></section></article><h3 id="Dimension-2"><a class="docs-heading-anchor" href="#Dimension-2">Dimension</a><a class="docs-heading-anchor-permalink" href="#Dimension-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Dimensions.dimensionOf-Tuple{AbstractQuantityArray}" href="#Alicorn.Dimensions.dimensionOf-Tuple{AbstractQuantityArray}"><code>Alicorn.Dimensions.dimensionOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">dimensionOf(quantityArray::AbstractQuantityArray)</code></pre><p>Returns the dimension of a physical quantity of type <a href="#Alicorn.Quantities.AbstractQuantityArray"><code>AbstractQuantityArray</code></a>, analogous to <a href="#Alicorn.Dimensions.dimensionOf-Tuple{AbstractQuantity}"><code>dimensionOf(::AbstractQuantity)</code></a> ```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_dimensions.jl#L23-L29">source</a></section></article><h3 id="Type-Conversion"><a class="docs-heading-anchor" href="#Type-Conversion">Type Conversion</a><a id="Type-Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Conversion" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantityArray-Tuple{AbstractQuantityArray}" href="#Alicorn.Quantities.SimpleQuantityArray-Tuple{AbstractQuantityArray}"><code>Alicorn.Quantities.SimpleQuantityArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SimpleQuantityArray(quantityArray::AbstractQuantityArray)</code></pre><p>Construct a <code>SimpleQuantityArray</code> from a physical quantity of any implementation of <code>AbstractQuantityArray</code>.</p><p>If <code>quantityArray</code> is of type <code>SimpleQuantityArray</code>, it is returned unchanged. If <code>quantityArray</code> is of type <code>QuantityArray</code>, it is expressed in terms of the SI units specified by <code>quantityArray.InternalUnits</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L154-L162">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantityArray-Union{Tuple{AbstractQuantityArray}, Tuple{T}} where T&lt;:Number" href="#Alicorn.Quantities.SimpleQuantityArray-Union{Tuple{AbstractQuantityArray}, Tuple{T}} where T&lt;:Number"><code>Alicorn.Quantities.SimpleQuantityArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SimpleQuantityArray{T}(::AbstractQuantityArray) where {T&lt;:Number}</code></pre><p>Construct a <code>SimpleQuantityArray{T}</code> with specified type <code>T</code> from a physical quantity of any implementation of <code>AbstractQuantityArray</code>.</p><p>See <code>SimpleQuantityArray(::AbstractQuantityArray)</code> for details.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>InexactError</code>: if the value of <code>AbstractQuantityArray</code> cannot be</li></ul><p>represented as type <code>Array{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L193-L204">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantityArray-Tuple{AbstractQuantity}" href="#Alicorn.Quantities.SimpleQuantityArray-Tuple{AbstractQuantity}"><code>Alicorn.Quantities.SimpleQuantityArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SimpleQuantityArray(quantity::AbstractQuantity)</code></pre><p>Construct a 1x1 <code>SimpleQuantityArray</code> from a physical quantity of any implementation of <code>AbstractQuantity</code>.</p><p>See <code>SimpleQuantityArray(::AbstractQuantityArray)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L174-L181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantityArray-Union{Tuple{AbstractQuantity}, Tuple{T}} where T&lt;:Number" href="#Alicorn.Quantities.SimpleQuantityArray-Union{Tuple{AbstractQuantity}, Tuple{T}} where T&lt;:Number"><code>Alicorn.Quantities.SimpleQuantityArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">SimpleQuantityArray{T}(quantity::AbstractQuantity) where {T&lt;:Number}</code></pre><p>Construct a 1x1 <code>SimpleQuantityArray{T}</code> with specified type <code>T</code> from a physical quantity of any implementation of <code>AbstractQuantity</code>.</p><p>See <code>SimpleQuantityArray(::AbstractQuantity)</code> for details.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>InexactError</code>: if the value of <code>AbstractQuantity</code> cannot be</li></ul><p>represented as type <code>Array{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L215-L226">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.QuantityArray-Tuple{AbstractQuantityArray, InternalUnits}" href="#Alicorn.Quantities.QuantityArray-Tuple{AbstractQuantityArray, InternalUnits}"><code>Alicorn.Quantities.QuantityArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QuantityArray(::AbstractQuantityArray, ::InternalUnits)
QuantityArray(::AbstractQuantityArray)</code></pre><p>Construct a <code>QuantityArray</code> from a physical quantity of any implementation of <code>AbstractQuantityArray</code>.</p><p>If no <code>InternalUnits</code> are specified, they are inferred from the <code>AbstractQuantityArray</code> if possible. Else, basic SI units are used.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L251-L259">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.QuantityArray-Union{Tuple{T}, Tuple{AbstractQuantityArray, InternalUnits}} where T&lt;:Number" href="#Alicorn.Quantities.QuantityArray-Union{Tuple{T}, Tuple{AbstractQuantityArray, InternalUnits}} where T&lt;:Number"><code>Alicorn.Quantities.QuantityArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QuantityArray{T}(::AbstractQuantityArray, ::InternalUnits) where {T&lt;:Number}
QuantityArray{T}(::AbstractQuantityArray) where {T&lt;:Number}</code></pre><p>Construct a <code>QuantityArray{T}</code> with specified type <code>T</code> from a physical quantity of any implementation of <code>AbstractQuantityArray</code>.</p><p>See <code>QuantityArray(::AbstractQuantityArray, ::InternalUnits)</code> for details.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>InexactError</code>: if the internal value of <code>AbstractQuantityArray</code> cannot be</li></ul><p>represented as type <code>Array{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L315-L327">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.QuantityArray-Tuple{AbstractQuantity, InternalUnits}" href="#Alicorn.Quantities.QuantityArray-Tuple{AbstractQuantity, InternalUnits}"><code>Alicorn.Quantities.QuantityArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QuantityArray(quantity::AbstractQuantity, ::InternalUnits)
QuantityArray(quantity::AbstractQuantity)</code></pre><p>Construct a 1x1 <code>QuantityArray</code> from a physical quantity of any implementation of <code>AbstractQuantity</code>.</p><p>See <code>QuantityArray(::AbstractQuantityArray)</code> for details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L284-L292">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.QuantityArray-Union{Tuple{T}, Tuple{AbstractQuantity, InternalUnits}} where T&lt;:Number" href="#Alicorn.Quantities.QuantityArray-Union{Tuple{T}, Tuple{AbstractQuantity, InternalUnits}} where T&lt;:Number"><code>Alicorn.Quantities.QuantityArray</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">QuantityArray{T}(::AbstractQuantity, ::InternalUnits) where {T&lt;:Number}
QuantityArray{T}(::AbstractQuantity) where {T&lt;:Number}</code></pre><p>Construct a <code>QuantityArray{T}</code> with specified type <code>T</code> from a physical quantity of any implementation of <code>AbstractQuantity</code>.</p><p>See <code>QuantityArray(::AbstractQuantity, ::InternalUnits)</code> for details.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>InexactError</code>: if the internal value of <code>AbstractQuantityArray</code> cannot be</li></ul><p>represented as type <code>Array{T}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L354-L366">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{T}, Tuple{Type{T}, SimpleQuantityArray}} where T&lt;:SimpleQuantityArray" href="#Base.convert-Union{Tuple{T}, Tuple{Type{T}, SimpleQuantityArray}} where T&lt;:SimpleQuantityArray"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.convert(::Type{T}, sqArray::SimpleQuantityArray) where {T&lt;:SimpleQuantityArray}</code></pre><p>Convert <code>sqArray</code> from type <code>SimpleQuantityArray{S} where S</code> to any subtype <code>T</code> of <code>SimpleQuantityArray</code>.</p><p>Allows to convert, for instance, from <code>SimpleQuantityArray{Float64}</code> to <code>SimpleQuantityVector{UInt8}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L238-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.convert-Union{Tuple{T}, Tuple{Type{T}, QuantityArray}} where T&lt;:QuantityArray" href="#Base.convert-Union{Tuple{T}, Tuple{Type{T}, QuantityArray}} where T&lt;:QuantityArray"><code>Base.convert</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.convert(::Type{T}, qArray::QuantityArray) where {T&lt;:QuantityArray}</code></pre><p>Convert <code>qArray</code> from type <code>QuantityArray{S} where S</code> to any subtype <code>T</code> of <code>QuantityArray</code>.</p><p>Allows to convert, for instance, from <code>QuantityArray{Float64}</code> to <code>QuantityVector{UInt8}</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_typeConversion.jl#L394-L401">source</a></section></article><h3 id="Unit-Conversion-2"><a class="docs-heading-anchor" href="#Unit-Conversion-2">Unit Conversion</a><a class="docs-heading-anchor-permalink" href="#Unit-Conversion-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inUnitsOf-Tuple{AbstractQuantityArray, AbstractUnit}" href="#Alicorn.Quantities.inUnitsOf-Tuple{AbstractQuantityArray, AbstractUnit}"><code>Alicorn.Quantities.inUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inUnitsOf(qArray::AbstractQuantityArray, unit::AbstractUnit)::SimpleQuantityArray</code></pre><p>Express <code>qArray</code> as an object of type <code>SimpleQuantityArray</code> in terms of the unit specified by <code>unit</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>qArray</code> and <code>unit</code> do not agree</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unitConversion.jl#L49-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inBasicSIUnits-Tuple{AbstractQuantityArray}" href="#Alicorn.Quantities.inBasicSIUnits-Tuple{AbstractQuantityArray}"><code>Alicorn.Quantities.inBasicSIUnits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inBasicSIUnits(qArray::AbstractQuantity)::SimpleQuantityArray</code></pre><p>Express <code>qArray</code> as an object of type <code>SimpleQuantityArray</code> using the seven basic SI units.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unitConversion.jl#L193-L197">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantityArray, AbstractUnit}" href="#Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantityArray, AbstractUnit}"><code>Alicorn.Quantities.valueInUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueInUnitsOf(qArray::AbstractQuantityArray, unit::AbstractUnit)</code></pre><p>Returns the numerical value of <code>qArray</code> expressed in units of <code>unit</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantity</code> and <code>unit</code> do not agree</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unitConversion.jl#L120-L127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueInUnitsOf-Union{Tuple{T}, Tuple{AbstractQuantityArray{T}, SimpleQuantity}} where T" href="#Alicorn.Quantities.valueInUnitsOf-Union{Tuple{T}, Tuple{AbstractQuantityArray{T}, SimpleQuantity}} where T"><code>Alicorn.Quantities.valueInUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueInUnitsOf(quantityArray::AbstractQuantityArray, simpleQuantity::SimpleQuantity)</code></pre><p>Returns the numerical value of <code>quantityArray</code> expressed in units of <code>simpleQuantity</code>.</p><p>The result is equivalent to <code>valueOfDimensionless(quantityArray / simpleQuantity)</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantityArray</code> and <code>simpleQuantity</code> do not agree</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unitConversion.jl#L130-L139">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueOfDimensionless-Tuple{AbstractQuantityArray}" href="#Alicorn.Quantities.valueOfDimensionless-Tuple{AbstractQuantityArray}"><code>Alicorn.Quantities.valueOfDimensionless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueOfDimensionless(qArray::AbstractQuantityArray)</code></pre><p>Strips the unit from a dimensionless quantity array and returns its bare value.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>qArray</code> is not dimensionless</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unitConversion.jl#L256-L263">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{AbstractQuantityArray, AbstractUnit}" href="#Base.:*-Tuple{AbstractQuantityArray, AbstractUnit}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(qArray::AbstractQuantityArray, unit::AbstractUnit)
Base.:*(unit::AbstractUnit, qArray::AbstractQuantityArray)</code></pre><p>Modify the unit of <code>qArray</code> by multiplying it with <code>unit</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unit_arithmetics.jl#L10-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{AbstractQuantityArray, AbstractUnit}" href="#Base.:/-Tuple{AbstractQuantityArray, AbstractUnit}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(qArray::AbstractQuantityArray, unit::AbstractUnit)
Base.:/(unit::AbstractUnit, qArray::AbstractQuantityArray)</code></pre><p>Modify the unit of <code>qArray</code> by dividing it by <code>unit</code>, or vice versa.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unit_arithmetics.jl#L40-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inInternalUnitsOf-Tuple{Quantity, InternalUnits}" href="#Alicorn.Quantities.inInternalUnitsOf-Tuple{Quantity, InternalUnits}"><code>Alicorn.Quantities.inInternalUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inInternalUnitsOf(quantity::Quantity{T}, targetIntU::InternalUnits) where T</code></pre><p>Returns a new <code>Quantity{S}</code> corresponding to <code>quantity</code>, but stored using <code>targetIntU</code> as new internal units.</p><p>The value type <code>S</code> of the returned quantity is identical to <code>T</code>, if possible.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_unitConversion.jl#L148-L155">source</a></section></article><h2 id="Array-Methods"><a class="docs-heading-anchor" href="#Array-Methods">Array Methods</a><a id="Array-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Array-Methods" title="Permalink"></a></h2><p><code>AbstractQuantityArray</code> and (where applicable) <code>AbstractQuantity</code> extend the interface of <code>AbstractArray</code> from Julia base.</p><table><tr><th style="text-align: left">Method</th><th style="text-align: center">Implemented for</th><th style="text-align: center">Remak</th></tr><tr><td style="text-align: left"><code>Base.size</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td><td style="text-align: center"></td></tr><tr><td style="text-align: left"><code>Base.IndexStyle</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td><td style="text-align: center">returns <code>IndexLinear()</code></td></tr><tr><td style="text-align: left"><code>Base.getindex</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td><td style="text-align: center">returns <code>SimpleQuantity</code> or <code>Quantity</code> if a single element is indexed</td></tr><tr><td style="text-align: left"><code>Base.setindex!</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td><td style="text-align: center">the assigned values have to be of matching type, e.g., <code>SimpleQuantity</code> or <code>SimpleQuantityArray</code> when assigning to a <code>SimpleQuantityArray</code></td></tr></table><p>Alicorn also extends the following methods for handling arrays from Julia base:</p><table><tr><th style="text-align: left">Method</th><th style="text-align: center">Implemented for</th></tr><tr><td style="text-align: left"><code>Base.eltype</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td></tr><tr><td style="text-align: left"><code>Base.copy</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td></tr><tr><td style="text-align: left"><code>Base.deepcopy</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td></tr><tr><td style="text-align: left"><code>Base.axes</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td></tr><tr><td style="text-align: left"><code>Base.ndims</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td></tr><tr><td style="text-align: left"><code>Base.length</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td></tr><tr><td style="text-align: left"><code>Base.firstindex</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td></tr><tr><td style="text-align: left"><code>Base.lastindex</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td></tr><tr><td style="text-align: left"><code>Base.IteratorSize</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a></td></tr><tr><td style="text-align: left"><code>Base.keys</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td></tr><tr><td style="text-align: left"><code>Base.get</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td></tr><tr><td style="text-align: left"><code>Base.first</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td></tr><tr><td style="text-align: left"><code>Base.last</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityType"><code>AbstractQuantityType</code></a></td></tr><tr><td style="text-align: left"><code>Base.deleteat!</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityVector"><code>AbstractQuantityVector</code></a></td></tr><tr><td style="text-align: left"><code>Base.repeat</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.AbstractQuantityArray"><code>AbstractQuantityArray</code></a></td></tr><tr><td style="text-align: left"><code>Base.iterate</code></td><td style="text-align: center"><a href="#Alicorn.Quantities.ScalarQuantity"><code>ScalarQuantity</code></a></td></tr></table><h2 id="Mathematics"><a class="docs-heading-anchor" href="#Mathematics">Mathematics</a><a id="Mathematics-1"></a><a class="docs-heading-anchor-permalink" href="#Mathematics" title="Permalink"></a></h2><p>Alicorn extends the following basic mathematical functions from Julia base to operate on <code>AbstractQuantity</code> and <code>AbstractQuantityArray</code> types.</p><h3 id="Arithmetics"><a class="docs-heading-anchor" href="#Arithmetics">Arithmetics</a><a id="Arithmetics-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetics" title="Permalink"></a></h3><p>Binary operations involving two quantities generally show the followig behavior:</p><ul><li>if a <a href="#Alicorn.Quantities.QuantityType"><code>QuantityType</code></a> object is combined with a <a href="#Alicorn.Quantities.SimpleQuantityType"><code>SimpleQuantityType</code></a>, the result is of type <a href="#Alicorn.Quantities.QuantityType"><code>QuantityType</code></a>.</li><li>if two <a href="#Alicorn.Quantities.SimpleQuantityType"><code>SimpleQuantityType</code></a> objects of the same dimension are added or subtracted, the result inherits the unit of the first argument</li><li>if two <a href="#Alicorn.Quantities.QuantityType"><code>QuantityType</code></a> objects are combined, the result inherits the <a href="#Alicorn.Quantities.InternalUnits"><code>InternalUnits</code></a> of the first argument</li></ul><table><tr><th style="text-align: left">Method</th><th style="text-align: center">Supports broadcasting</th></tr><tr><td style="text-align: left">unary plus <code>Base.:+(::AbstractQuantityType)</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left">unary minus <code>Base.:-(::AbstractQuantityType)</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left">addition <code>Base.:+</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left">subtraction <code>Base.:-</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left">multiplication <code>Base.:*</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left">division <code>Base.:*</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left">power <code>Base.:^</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left">inverse <code>Base.inv</code></td><td style="text-align: center">yes</td></tr></table><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{SimpleQuantityType, SimpleQuantityType}" href="#Base.:+-Tuple{SimpleQuantityType, SimpleQuantityType}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:+(q1::SimpleQuantity, q2::SimpleQuantity)
Base.:+(q1::SimpleQuantityArray, q2::SimpleQuantityArray)</code></pre><p>Add two objects of type <code>SimpleQuantity</code> or <code>SimpleQuantityArray</code>.</p><p>The resulting quantity is expressed in units of <code>q1</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>q1</code> and <code>q2</code> are of different dimensions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_math.jl#L17-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{Quantity, Quantity}" href="#Base.:+-Tuple{Quantity, Quantity}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:+(q1::Quantity, q2::Quantity)
Base.:+(q1::QuantityArray, q2::QuantityArray)</code></pre><p>Add two objects of type <code>Quantity</code> or <code>QuantityArray</code>.</p><p>The resulting quantity is expressed in internal units of <code>q1</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>q1</code> and <code>q2</code> are of different dimensions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_math.jl#L34-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{SimpleQuantity, Quantity}" href="#Base.:+-Tuple{SimpleQuantity, Quantity}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:+(q1::SimpleQuantity, q2::Quantity)
Base.:+(q1::Quantity, q2::SimpleQuantity)
Base.:+(q1::SimpleQuantityArray, q2::QuantityArray)
Base.:+(q1::QuantityArray, q2::SimpleQuantityArray)</code></pre><p>Add two objects of type <code>SimpleQuantity</code> and <code>Quantity</code>, or <code>SimpleQuantityArray</code> and <code>QuantityArray</code>.</p><p>Returns a quantity of type <code>Quantity</code> or <code>QuantityArray</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>q1</code> and <code>q2</code> are of different dimensions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_math.jl#L64-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{SimpleQuantityType, SimpleQuantityType}" href="#Base.:--Tuple{SimpleQuantityType, SimpleQuantityType}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:-(q1::SimpleQuantity, q2::SimpleQuantity)
Base.:-(q1::SimpleQuantityArray, q2::SimpleQuantityArray)</code></pre><p>Subtract two objects of type <code>SimpleQuantity</code> or <code>SimpleQuantityArray</code>.</p><p>The resulting quantity is expressed in units of <code>q1</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>q1</code> and <code>q2</code> are of different dimensions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_math.jl#L84-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{QuantityType, QuantityType}" href="#Base.:--Tuple{QuantityType, QuantityType}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:-(q1::Quantity, q2::Quantity)
Base.:-(q1::QuantityArray, q2::QuantityArray)</code></pre><p>Subtract two objects of type <code>Quantity</code> or <code>QuantityArray</code>.</p><p>The resulting quantity is expressed in internal units of <code>q1</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>q1</code> and <code>q2</code> are of different dimensions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_math.jl#L97-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{SimpleQuantityType, QuantityType}" href="#Base.:--Tuple{SimpleQuantityType, QuantityType}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:-(q1::SimpleQuantity, q2::Quantity)
Base.:-(q1::Quantity, q2::SimpleQuantity)
Base.:-(q1::SimpleQuantityArray, q2::QuantityArray)
Base.:-(q1::QuantityArray, q2::SimpleQuantityArray)</code></pre><p>Subtract two objects of type <code>SimpleQuantity</code> and <code>Quantity</code>, or <code>SimpleQuantityArray</code> and <code>QuantityArray</code>.</p><p>Returns a quantity of type <code>Quantity</code> or <code>QuantityArray</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>q1</code> and <code>q2</code> are of different dimensions</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_math.jl#L110-L122">source</a></section></article><h3 id="Numeric-Comparison"><a class="docs-heading-anchor" href="#Numeric-Comparison">Numeric Comparison</a><a id="Numeric-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Numeric-Comparison" title="Permalink"></a></h3><p>Numeric comparison is only possible between</p><ul><li><a href="#Alicorn.Quantities.SimpleQuantityType"><code>SimpleQuantityType</code></a> objects that have the same units</li><li><a href="#Alicorn.Quantities.QuantityType"><code>QuantityType</code></a> objects that have the same internal units.</li></ul><p>In particular, comparison with <code>==</code> fails if this is not the case.</p><table><tr><th style="text-align: left">Method</th><th style="text-align: center">Supports broadcasting</th><th style="text-align: center">Remarks</th></tr><tr><td style="text-align: left"><code>Base.(==)</code></td><td style="text-align: center">yes</td><td style="text-align: center"></td></tr><tr><td style="text-align: left"><code>Base.&lt;</code></td><td style="text-align: center">yes</td><td style="text-align: center"></td></tr><tr><td style="text-align: left"><code>Base.(&lt;=)</code></td><td style="text-align: center">yes</td><td style="text-align: center"></td></tr><tr><td style="text-align: left"><code>Base.&gt;</code></td><td style="text-align: center">yes</td><td style="text-align: center"></td></tr><tr><td style="text-align: left"><code>Base.(&gt;=)</code></td><td style="text-align: center">yes</td><td style="text-align: center"></td></tr><tr><td style="text-align: left"><code>Base.isapprox</code></td><td style="text-align: center">yes</td><td style="text-align: center"></td></tr><tr><td style="text-align: left"><code>Base.isfinite</code></td><td style="text-align: center">no</td><td style="text-align: center">only for <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a></td></tr><tr><td style="text-align: left"><code>Base.isinf</code></td><td style="text-align: center">no</td><td style="text-align: center">only for <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a></td></tr><tr><td style="text-align: left"><code>Base.isnan</code></td><td style="text-align: center">no</td><td style="text-align: center">only for <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a></td></tr></table><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{SimpleQuantityType, SimpleQuantityType}" href="#Base.:==-Tuple{SimpleQuantityType, SimpleQuantityType}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:(==)(q1::SimpleQuantity, q2::SimpleQuantity)
Base.:(==)(q1::SimpleQuantityArray, q2::SimpleQuantityArray)</code></pre><p>Returns <code>true</code> if <code>q1</code> and <code>q2</code> are of equal value and unit.</p><p>Note that the units are not converted during the comparison.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; q1 = 7 * ucat.meter
7 m

julia&gt; q2 = 700 * (ucat.centi * ucat.meter)
700 cm

julia&gt; q1 == q1
true

julia&gt; q1 == q2
false</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_math.jl#L306-L330">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{QuantityType, QuantityType}" href="#Base.:==-Tuple{QuantityType, QuantityType}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:(==)(q1::Quantity, q2::Quantity)
Base.:(==)(q1::QuantityArray, q2::QuantityArray)</code></pre><p>Compare two <code>Quantity</code> or <code>QuantityArray</code> objects.</p><p>The two quantities are equal if their values, their dimensions, and their internal units are equal. Note that the internal units are not converted during the comparison.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_math.jl#L337-L345">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{SimpleQuantity, SimpleQuantity}" href="#Base.isless-Tuple{SimpleQuantity, SimpleQuantity}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.isless(q1::SimpleQuantity, q2::SimpleQuantity)</code></pre><p>Returns <code>true</code> if <code>q1</code> is of lesser value than <code>q2</code>.</p><p>Note that units are not converted during the comparison.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.UnitMismatchError</code>: if <code>q1</code> and</li></ul><p><code>q2</code> are not of the same unit</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_math.jl#L357-L367">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{Quantity, Quantity}" href="#Base.isless-Tuple{Quantity, Quantity}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.isless(q1::Quantity, q2::Quantity)</code></pre><p>Returns <code>true</code> if <code>q1</code> is of lesser value than <code>q2</code>.</p><p>Note that internal units are not converted during the comparison.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>q1</code> and <code>q2</code> are not of the same dimension</li><li><code>Alicorn.Exceptions.UnitMismatchError</code>: if <code>q1</code> and <code>q2</code> are not using the same internal units</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_math.jl#L374-L384">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{SimpleQuantityType, SimpleQuantityType}" href="#Base.isapprox-Tuple{SimpleQuantityType, SimpleQuantityType}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.isapprox(q1::SimpleQuantity, q2::SimpleQuantity; rtol::Real = sqrt(eps()) )
Base.isapprox(q1::SimpleQuantityArray, q2::SimpleQuantityArray; rtol::Real = sqrt(eps()) )</code></pre><p>Returns <code>isapprox(q1.value, q2.value, rtol=rtol)</code>.</p><p>Note that units are not converted during the comparison. Returns <code>false</code> if the two quantities are not of equal physical dimension.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_math.jl#L420-L427">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{QuantityType, QuantityType}" href="#Base.isapprox-Tuple{QuantityType, QuantityType}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.isapprox(q1::Quantity, q2::Quantity; rtol::Real = sqrt(eps()) )
Base.isapprox(q1::QuantityArray, q2::QuantityArray; rtol::Real = sqrt(eps()) )</code></pre><p>Returns <code>isapprox(q1.value, q2.value, rtol=rtol)</code>.</p><p>Note that internal units are not converted during the comparison.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>q1</code> and <code>q2</code> are not of the same dimension</li><li><code>Alicorn.Exceptions.UnitMismatchError</code>: if <code>q1</code> and <code>q2</code> are not using the same internal units</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Huemmer-Daniel/Alicorn/blob/f3f74b1842339b02671597c629472b3ed81cbc04/src/Quantities/quantity_math.jl#L433-L444">source</a></section></article><h3 id="Sign-and-Absolute-Value"><a class="docs-heading-anchor" href="#Sign-and-Absolute-Value">Sign and Absolute Value</a><a id="Sign-and-Absolute-Value-1"></a><a class="docs-heading-anchor-permalink" href="#Sign-and-Absolute-Value" title="Permalink"></a></h3><table><tr><th style="text-align: left">Method</th><th style="text-align: center">Supports broadcasting</th><th style="text-align: center">Remarks</th></tr><tr><td style="text-align: left"><code>Base.abs</code></td><td style="text-align: center">yes</td><td style="text-align: center">only for <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a></td></tr><tr><td style="text-align: left"><code>Base.abs2</code></td><td style="text-align: center">yes</td><td style="text-align: center">only for <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a></td></tr><tr><td style="text-align: left"><code>Base.sign</code></td><td style="text-align: center">yes</td><td style="text-align: center">only for <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a></td></tr><tr><td style="text-align: left"><code>Base.signbit</code></td><td style="text-align: center">no</td><td style="text-align: center">only for <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a></td></tr><tr><td style="text-align: left"><code>Base.copysign</code></td><td style="text-align: center">no</td><td style="text-align: center">only for <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a></td></tr><tr><td style="text-align: left"><code>Base.flipsign</code></td><td style="text-align: center">no</td><td style="text-align: center">only for <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a></td></tr></table><h3 id="Roots"><a class="docs-heading-anchor" href="#Roots">Roots</a><a id="Roots-1"></a><a class="docs-heading-anchor-permalink" href="#Roots" title="Permalink"></a></h3><table><tr><th style="text-align: left">Method</th><th style="text-align: center">Supports broadcasting</th><th style="text-align: center">Remarks</th></tr><tr><td style="text-align: left"><code>Base.sqrt</code></td><td style="text-align: center">yes</td><td style="text-align: center">only for <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a></td></tr><tr><td style="text-align: left"><code>Base.cbrt</code></td><td style="text-align: center">yes</td><td style="text-align: center">only for <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a></td></tr></table><h3 id="Complex-Numbers"><a class="docs-heading-anchor" href="#Complex-Numbers">Complex Numbers</a><a id="Complex-Numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-Numbers" title="Permalink"></a></h3><table><tr><th style="text-align: left">Method</th><th style="text-align: center">Supports broadcasting</th><th style="text-align: center">Remarks</th></tr><tr><td style="text-align: left"><code>Base.real</code></td><td style="text-align: center">yes</td><td style="text-align: center"></td></tr><tr><td style="text-align: left"><code>Base.imag</code></td><td style="text-align: center">yes</td><td style="text-align: center"></td></tr><tr><td style="text-align: left"><code>Base.angle</code></td><td style="text-align: center">yes</td><td style="text-align: center">only for <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a></td></tr><tr><td style="text-align: left"><code>Base.conj</code></td><td style="text-align: center">yes</td><td style="text-align: center"></td></tr></table><h2 id="Broadcasting"><a class="docs-heading-anchor" href="#Broadcasting">Broadcasting</a><a id="Broadcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Broadcasting" title="Permalink"></a></h2><p>Alicorn offers broadcasting for most mathematical functions available for quantities. For example:</p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; M = [2 3; 4 5] * ucat.meter ;

julia&gt; q = Quantity(2 * ucat.meter) ;

julia&gt; M .+ q
2×2 QuantityMatrix{Int64} of dimension L^1 in units of (1 m):
 4  5
 6  7</code></pre><p>The tables in the previous section indicate which functions support broadcasting.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dimensions/">« Dimensions</a><a class="docs-footer-nextpage" href="../">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 6 October 2022 14:45">Thursday 6 October 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
