<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantities · Alicorn.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Alicorn.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Alicorn.jl logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/basic_usage/">Basic Usage</a></li><li><a class="tocitem" href="../../manual/advanced_usage/">Advanced Usage</a></li><li><a class="tocitem" href="../../manual/caveats/">Caveats</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../units/">Units</a></li><li><a class="tocitem" href="../dimensions/">Dimensions</a></li><li class="is-active"><a class="tocitem" href>Quantities</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Scalar-quantities"><span>Scalar quantities</span></a></li><li><a class="tocitem" href="#Array-quantities"><span>Array quantities</span></a></li><li><a class="tocitem" href="#InternalUnits"><span>InternalUnits</span></a></li></ul></li><li><a class="tocitem" href="../">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Quantities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quantities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/reference/quantities.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantities"><a class="docs-heading-anchor" href="#Quantities">Quantities</a><a id="Quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Quantities" title="Permalink"></a></h1><p>This section describes the Quantities submodule of Alicorn. The module is concerned with defining and manipulating physical quantities.</p><p>Unless stated otherwise, all types, functions, and constants defined in the submodule are exported to the global scope.</p><h4 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h4><ul><li><a href="#Quantities">Quantities</a></li><ul><li><a href="#Overview">Overview</a></li><li><a href="#Scalar-quantities">Scalar quantities</a></li><ul><li><a href="#Types">Types</a></li><li><a href="#Construction">Construction</a></li><li><a href="#Dimension">Dimension</a></li><li><a href="#Unit-conversion">Unit conversion</a></li><li><a href="#Arithmetics,-elementary-functions">Arithmetics, elementary functions</a></li><li><a href="#Numeric-comparison">Numeric comparison</a></li><li><a href="#Rounding">Rounding</a></li><li><a href="#Sign,-absolute-value">Sign, absolute value</a></li><li><a href="#Complex-numbers">Complex numbers</a></li></ul><li><a href="#Array-quantities">Array quantities</a></li><ul><li><a href="#Types-2">Types</a></li><li><a href="#Construction-2">Construction</a></li><li><a href="#Dimension-2">Dimension</a></li><li><a href="#Unit-conversion-2">Unit conversion</a></li><li><a href="#Arithmetics,-elementary-functions-2">Arithmetics, elementary functions</a></li><li><a href="#Numeric-comparison-2">Numeric comparison</a></li></ul><li><a href="#InternalUnits">InternalUnits</a></li></ul></ul><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Alicorn distinguishes scalar (number-valued) and array (vector-, matrix-, or tensor-valued) quantities. The abstract superype for all scalar quantities is <a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity</code></a>, while the abstract supertype for all array quantities is <a href="#Alicorn.Quantities.AbstractQuantityArray"><code>AbstractQuantityArray</code></a>. <code>AbstractQuantityArray</code> is a subtype of <code>Base.AbstractQuantity</code> and implements its interface.</p><h4 id="Types-representing-quantities"><a class="docs-heading-anchor" href="#Types-representing-quantities">Types representing quantities</a><a id="Types-representing-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Types-representing-quantities" title="Permalink"></a></h4><p>There are two concrete implementations of each supertype:</p><ul><li><a href="#Alicorn.Quantities.SimpleQuantity"><code>SimpleQuantity</code></a> and <a href="#Alicorn.Quantities.Quantity"><code>Quantity</code></a> for scalar quantities, and</li><li><a href="#Alicorn.Quantities.SimpleQuantityArray"><code>SimpleQuantityArray</code></a> and <a href="#Alicorn.Quantities.QuantityArray"><code>QuantityArray</code></a> for array quantities.</li></ul><p>The type graph for physical quantities is</p><pre><code class="language-none">AbstractQuantity{T}
├─ SimpleQuantity{T}
└─ Quantity{T}

AbstractQuantityArray{T,N} &lt;: AbstractArray{T,N}
├─ SimpleQuantityArray{T,N}
└─ QuantityArray{T,N}</code></pre><p>The <code>SimpleQuantity</code> and <code>SimpleQuantityArray</code> types store their numerical values expressed directly with respect to their unit.</p><p>The <code>Quantity</code> and <code>QuantityArray</code> types store their numerical values expressed with respect to a shared set of internal units for the seven basic physical dimensions of the SI system. These internal units are represented by a <a href="#Alicorn.Quantities.InternalUnits"><code>InternalUnits</code></a> object. Instead of a concrete units for each quantity, only their physical dimension is retained. This approach can reduce the need for unit conversions during calculations. Moreover, it facilitates the use of a global set of internal units adapted to the magnitudes of the quantities appearing in a given calculation.</p><h4 id="Type-aliases"><a class="docs-heading-anchor" href="#Type-aliases">Type aliases</a><a id="Type-aliases-1"></a><a class="docs-heading-anchor-permalink" href="#Type-aliases" title="Permalink"></a></h4><p>Alicorn defines aliases for one- and two-dimensional arrays, and type unions representing both dimensional and dimensionless values.</p><table><tr><th style="text-align: left">Type name</th><th style="text-align: center">Mathematical dimension</th><th style="text-align: center">Role</th><th style="text-align: center">Alias for</th><th style="text-align: center">Carries physical dimension</th></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.AbstractQuantity"><code>AbstractQuantity{T}</code></a></td><td style="text-align: center">N=0</td><td style="text-align: center">abstract supertype</td><td style="text-align: center">-</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.AbstractQuantityVector"><code>AbstractQuantityVector{T}</code></a></td><td style="text-align: center">N=1</td><td style="text-align: center">abstract supertype</td><td style="text-align: center"><code>AbstractQuantityArray{T,1}</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.AbstractQuantityMatrix"><code>AbstractQuantityMatrix{T}</code></a></td><td style="text-align: center">N=2</td><td style="text-align: center">abstract supertype</td><td style="text-align: center"><code>AbstractQuantityArray{T,2}</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.AbstractQuantityArray"><code>AbstractQuantityArray{T,N}</code></a></td><td style="text-align: center">N</td><td style="text-align: center">abstract supertype</td><td style="text-align: center">-</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.SimpleQuantity"><code>SimpleQuantity{T}</code></a></td><td style="text-align: center">N=0</td><td style="text-align: center">concrete type</td><td style="text-align: center">-</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.SimpleQuantityVector"><code>SimpleQuantityVector{T}</code></a></td><td style="text-align: center">N=1</td><td style="text-align: center">concrete type</td><td style="text-align: center"><code>SimpleQuantityArray{T,1}</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.SimpleQuantityMatrix"><code>SimpleQuantityMatrix{T}</code></a></td><td style="text-align: center">N=2</td><td style="text-align: center">concrete type</td><td style="text-align: center"><code>SimpleQuantityArray{T,2}</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.SimpleQuantityArray"><code>SimpleQuantityArray{T,N}</code></a></td><td style="text-align: center">N</td><td style="text-align: center">concrete type</td><td style="text-align: center">-</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.Quantity"><code>Quantity{T}</code></a></td><td style="text-align: center">N=0</td><td style="text-align: center">concrete type</td><td style="text-align: center">-</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.QuantityVector"><code>QuantityVector{T}</code></a></td><td style="text-align: center">N=1</td><td style="text-align: center">concrete type</td><td style="text-align: center"><code>QuantityArray{T,1}</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.QuantityMatrix"><code>QuantityMatrix{T}</code></a></td><td style="text-align: center">N=2</td><td style="text-align: center">concrete type</td><td style="text-align: center"><code>QuantityArray{T,2}</code></td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.QuantityArray"><code>QuantityArray{T,N}</code></a></td><td style="text-align: center">N</td><td style="text-align: center">concrete type</td><td style="text-align: center">-</td><td style="text-align: center">yes</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.ScalarQuantity"><code>ScalarQuantity{T}</code></a></td><td style="text-align: center">N=0</td><td style="text-align: center">type union</td><td style="text-align: center"><code>Union{T, AbstractQuantity{T}} where T&lt;:Number</code></td><td style="text-align: center">either yes or no</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.VectorQuantity"><code>VectorQuantity{T}</code></a></td><td style="text-align: center">N=1</td><td style="text-align: center">type union</td><td style="text-align: center"><code>Union{T, AbstractQuantityVector{T}} where T&lt;:Number</code></td><td style="text-align: center">either yes or no</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.MatrixQuantity"><code>MatrixQuantity{T}</code></a></td><td style="text-align: center">N=2</td><td style="text-align: center">type union</td><td style="text-align: center"><code>Union{T, AbstractQuantityMatrix{T}} where T&lt;:Number</code></td><td style="text-align: center">either yes or no</td></tr><tr><td style="text-align: left"><a href="#Alicorn.Quantities.ArrayQuantity"><code>ArrayQuantity{T,N}</code></a></td><td style="text-align: center">N</td><td style="text-align: center">type union</td><td style="text-align: center"><code>Union{Array{T,N}, AbstractQuantityArray{T,N}} where {T&lt;:Number, N}</code></td><td style="text-align: center">either yes or no</td></tr></table><h2 id="Scalar-quantities"><a class="docs-heading-anchor" href="#Scalar-quantities">Scalar quantities</a><a id="Scalar-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Scalar-quantities" title="Permalink"></a></h2><h3 id="Types"><a class="docs-heading-anchor" href="#Types">Types</a><a id="Types-1"></a><a class="docs-heading-anchor-permalink" href="#Types" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.AbstractQuantity" href="#Alicorn.Quantities.AbstractQuantity"><code>Alicorn.Quantities.AbstractQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractQuantity{T&lt;:Number}</code></pre><p>Abstract supertype for all quantities that have a scalar value (number) of type <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantity" href="#Alicorn.Quantities.SimpleQuantity"><code>Alicorn.Quantities.SimpleQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleQuantity{T&lt;:Number} &lt;: AbstractQuantity{T}</code></pre><p>A physical quantity consisting of a scalar value and a physical unit.</p><p><strong>Fields</strong></p><ul><li><code>value::T</code>: value of the quantity</li><li><code>unit::Unit</code>: unit of the quantity</li></ul><p><strong>Constructors</strong></p><pre><code class="language-none">SimpleQuantity(value::T, abstractUnit::AbstractUnit) where T &lt;: Number
SimpleQuantity(value::T) where T &lt;: Number
SimpleQuantity(abstractUnit::AbstractUnit)
SimpleQuantity(simpleQuantity::SimpleQuantity)</code></pre><p>If no <code>AbstractUnit</code> is passed to the constructor, the <code>Alicorn.unitlessUnit</code> is used by default. If no value is passed to the constructor, the value is set to 1 by default.</p><p><strong>Examples</strong></p><ol><li><p>The quantity <span>$7\,\mathrm{nm}$</span> (seven nanometers) can be constructed using the constructor method as follows:</p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; nanometer = ucat.nano * ucat.meter
UnitFactor nm

julia&gt; quantity = SimpleQuantity(7, nanometer)
7 nm</code></pre></li><li><p>Alternatively, <span>$7\,\mathrm{nm}$</span> can be constructed arithmetically:</p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; nm = ucat.nano * ucat.meter
UnitFactor nm

julia&gt; quantity = 7nm
7 nm</code></pre></li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.Quantity" href="#Alicorn.Quantities.Quantity"><code>Alicorn.Quantities.Quantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Quantity{T&lt;:Number} &lt;: AbstractQuantity{T}</code></pre><p>A physical quantity consisting of a number, a <code>Dimension</code> object representing the physical dimension, and an <code>InternalUnits</code> object representing the units with respect to which the seven basic dimensions of the SI system are measured.</p><p>The value field of a <code>Quantity{T}</code> is of type <code>T</code>, which needs to be a subtype of <code>Number</code>.</p><p><strong>Fields</strong></p><ul><li><code>value::T</code>: value of the quantity</li><li><code>dimension::Dimension</code>: physical dimension of the quantity</li><li><code>internalUnits::InternalUnits</code>: set of units with respect to which the seven</li></ul><p>basic dimensions of the SI system are measured.</p><p><strong>Constructors</strong></p><pre><code class="language-none">Quantity(value::T, dimension::Dimension, internalUnits::InternalUnits) where T &lt;: Number
Quantity(simpleQuantity::SimpleQuantity, internalUnits::InternalUnits)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.ScalarQuantity" href="#Alicorn.Quantities.ScalarQuantity"><code>Alicorn.Quantities.ScalarQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ScalarQuantity{T}</code></pre><p>Type union representing a scalar (number) of type <code>T</code>, with or without a unit.</p><p>Alias for <code>Union{T, AbstractQuantity{T}} where T&lt;:Number</code>.</p></div></section></article><h3 id="Construction"><a class="docs-heading-anchor" href="#Construction">Construction</a><a id="Construction-1"></a><a class="docs-heading-anchor-permalink" href="#Construction" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Number, AbstractUnit}" href="#Base.:*-Tuple{Number, AbstractUnit}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(value::Number, abstractUnit::AbstractUnit)</code></pre><p>Combine <code>value</code> and <code>abstractUnit</code> to form a physical quantity of type <code>SimpleQuantity</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; 3.5 * ucat.tesla
3.5 T</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{Number, AbstractUnit}" href="#Base.:/-Tuple{Number, AbstractUnit}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(value::Number, abstractUnit::AbstractUnit)</code></pre><p>Combine <code>value</code> and <code>abstractUnit</code> to form a physical quantity of type <code>SimpleQuantity</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; 3.5 / ucat.second
3.5 s^-1</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zero-Tuple{Type, AbstractUnit}" href="#Base.zero-Tuple{Type, AbstractUnit}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.zero(numberType::Type, unit::AbstractUnit)</code></pre><p>Return a <code>SimpleQuantity</code> with unit <code>unit</code> and value <code>zero(numberType)</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.DomainError</code>: if <code>numberType</code> is not a subtype of <code>Number</code>.</li></ul></div></section></article><h3 id="Dimension"><a class="docs-heading-anchor" href="#Dimension">Dimension</a><a id="Dimension-1"></a><a class="docs-heading-anchor-permalink" href="#Dimension" title="Permalink"></a></h3><h3 id="Unit-conversion"><a class="docs-heading-anchor" href="#Unit-conversion">Unit conversion</a><a id="Unit-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-conversion" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inUnitsOf-Tuple{AbstractQuantity, AbstractUnit}" href="#Alicorn.Quantities.inUnitsOf-Tuple{AbstractQuantity, AbstractUnit}"><code>Alicorn.Quantities.inUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inUnitsOf(quantity::AbstractQuantity, unit::AbstractUnit)::SimpleQuantity</code></pre><p>Express <code>quantity</code> as an object of type <code>SimpleQuantity</code> in terms of the unit specified by <code>unit</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantity</code> and <code>unit</code> do not agree</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inBasicSIUnits-Tuple{AbstractQuantity}" href="#Alicorn.Quantities.inBasicSIUnits-Tuple{AbstractQuantity}"><code>Alicorn.Quantities.inBasicSIUnits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inBasicSIUnits(quantity::AbstractQuantity)::SimpleQuantity</code></pre><p>Express <code>quantity</code> as an object of type <code>SimpleQuantity</code> using the seven basic SI units.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantity, AbstractUnit}" href="#Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantity, AbstractUnit}"><code>Alicorn.Quantities.valueInUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueInUnitsOf(quantity::AbstractQuantity, unit::AbstractUnit)</code></pre><p>Returns the numerical value of <code>quantity</code> expressed in units of <code>unit</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantity</code> and <code>unit</code> do not agree</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantity, SimpleQuantity}" href="#Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantity, SimpleQuantity}"><code>Alicorn.Quantities.valueInUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueInUnitsOf(quantity::AbstractQuantity, simpleQuantity::SimpleQuantity)</code></pre><p>Returns the numerical value of <code>quantity</code> expressed in units of <code>simpleQuantity</code>.</p><p>The result is equivalent to <code>valueOfDimensionless(quantity / simpleQuantity)</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantity</code> and <code>simpleQuantity</code> do not agree</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueOfDimensionless-Tuple{AbstractQuantity}" href="#Alicorn.Quantities.valueOfDimensionless-Tuple{AbstractQuantity}"><code>Alicorn.Quantities.valueOfDimensionless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueOfDimensionless(quantity::AbstractQuantity)</code></pre><p>Strips the unit from a dimensionless quantity and returns its bare value.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>quantity</code> is not dimensionless</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueOfDimensionless-Tuple{SimpleQuantity}" href="#Alicorn.Quantities.valueOfDimensionless-Tuple{SimpleQuantity}"><code>Alicorn.Quantities.valueOfDimensionless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueOfDimensionless(quantity::AbstractQuantity)</code></pre><p>Strips the unit from a dimensionless quantity and returns its bare value.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>quantity</code> is not dimensionless</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{AbstractQuantity, AbstractUnit}" href="#Base.:*-Tuple{AbstractQuantity, AbstractUnit}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(quantity::AbstractQuantity, unit::AbstractUnit)
Base.:*(unit::AbstractUnit, quantity::AbstractQuantity)</code></pre><p>Modify the unit of <code>quantity</code> by multiplying it with <code>unit</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{AbstractQuantity, AbstractUnit}" href="#Base.:/-Tuple{AbstractQuantity, AbstractUnit}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(quantity::AbstractQuantity, unit::AbstractUnit)
Base.:/(unit::AbstractUnit, quantity::AbstractQuantity)</code></pre><p>Modify the unit of <code>quantity</code> by dividing it by <code>unit</code>, or vice versa.</p></div></section></article><h3 id="Arithmetics,-elementary-functions"><a class="docs-heading-anchor" href="#Arithmetics,-elementary-functions">Arithmetics, elementary functions</a><a id="Arithmetics,-elementary-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetics,-elementary-functions" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{SimpleQuantity, SimpleQuantity}" href="#Base.:+-Tuple{SimpleQuantity, SimpleQuantity}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:+(simpleQuantity1::SimpleQuantity, simpleQuantity2::SimpleQuantity)</code></pre><p>Add two SimpleQuantities.</p><p>The resulting quantity is expressed in units of <code>simpleQuantity1</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>simpleQuantity1</code> and <code>simpleQuantity2</code> are of different dimensions</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{SimpleQuantity, SimpleQuantity}" href="#Base.:--Tuple{SimpleQuantity, SimpleQuantity}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:-(simpleQuantity1::SimpleQuantity, simpleQuantity2::SimpleQuantity)</code></pre><p>Subtract two SimpleQuantities.</p><p>The resulting quantity is expressed in units of <code>simpleQuantity1</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>simpleQuantity1</code> and <code>simpleQuantity2</code> are of different dimensions</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{SimpleQuantity, SimpleQuantity}" href="#Base.isless-Tuple{SimpleQuantity, SimpleQuantity}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.isless(simpleQuantity1::SimpleQuantity, simpleQuantity2::SimpleQuantity)</code></pre><p>Returns <code>true</code> if <code>simpleQuantity1</code> is of lesser value than <code>simpleQuantity2</code>.</p><p>If necessary, <code>simpleQuantity2</code> is expressed in units of <code>simpleQuantity1.unit</code> before the comparison. Note that the conversion often leads to rounding errors.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>simpleQuantity1</code> and</li></ul><p><code>simpleQuantity2</code> are not of the same dimension</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{SimpleQuantity, SimpleQuantity}" href="#Base.isapprox-Tuple{SimpleQuantity, SimpleQuantity}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.isapprox(simpleQuantity1::SimpleQuantity, simpleQuantity2::SimpleQuantity; rtol::Real = sqrt(eps()) )</code></pre><p>Returns <code>isapprox(simpleQuantity1.value, simpleQuantity2.value, rtol=rtol)</code>.</p><p>If necessary, <code>simpleQuantity2</code> is expressed in units of <code>simpleQuantity1.unit</code> before the comparison. Note that the conversion often leads to rounding errors.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>simpleQuantity1</code> and</li></ul><p><code>simpleQuantity2</code> are not of the same dimension</p></div></section></article><h3 id="Numeric-comparison"><a class="docs-heading-anchor" href="#Numeric-comparison">Numeric comparison</a><a id="Numeric-comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Numeric-comparison" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{SimpleQuantity, SimpleQuantity}" href="#Base.:==-Tuple{SimpleQuantity, SimpleQuantity}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:(==)(simpleQuantity1::SimpleQuantity, simpleQuantity2::SimpleQuantity)</code></pre><p>Returns <code>true</code> if <code>simpleQuantity1</code> and <code>simpleQuantity2</code> are of equal value.</p><p>If necessary, <code>simpleQuantity2</code> is expressed in units of <code>simpleQuantity1.unit</code> before the comparison. Note that the conversion oftens lead to rounding errors that render <code>simpleQuantity1</code> not equal <code>simpleQuantity2</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>simpleQuantity1</code> and</li></ul><p><code>simpleQuantity2</code> are not of the same dimension</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; q1 = 7 * ucat.meter
7 m

julia&gt; q2 = 700 * (ucat.centi * ucat.meter)
700 cm

julia&gt; q1 == q1
true

julia&gt; q1 == q2
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Quantity, Quantity}" href="#Base.:==-Tuple{Quantity, Quantity}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:(==)(quantity1::Quantity, quantity2::Quantity)</code></pre><p>Compare two <code>Quantity</code> objects.</p><p>The two quantities are equal if their values, their dimensions, and their internal units are equal. Note that the units are not converted during the comparison.</p></div></section></article><h3 id="Rounding"><a class="docs-heading-anchor" href="#Rounding">Rounding</a><a id="Rounding-1"></a><a class="docs-heading-anchor-permalink" href="#Rounding" title="Permalink"></a></h3><h3 id="Sign,-absolute-value"><a class="docs-heading-anchor" href="#Sign,-absolute-value">Sign, absolute value</a><a id="Sign,-absolute-value-1"></a><a class="docs-heading-anchor-permalink" href="#Sign,-absolute-value" title="Permalink"></a></h3><h3 id="Complex-numbers"><a class="docs-heading-anchor" href="#Complex-numbers">Complex numbers</a><a id="Complex-numbers-1"></a><a class="docs-heading-anchor-permalink" href="#Complex-numbers" title="Permalink"></a></h3><h2 id="Array-quantities"><a class="docs-heading-anchor" href="#Array-quantities">Array quantities</a><a id="Array-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Array-quantities" title="Permalink"></a></h2><h3 id="Types-2"><a class="docs-heading-anchor" href="#Types-2">Types</a><a class="docs-heading-anchor-permalink" href="#Types-2" title="Permalink"></a></h3><h4 id="Array-valued-abstract-supertypes"><a class="docs-heading-anchor" href="#Array-valued-abstract-supertypes">Array-valued abstract supertypes</a><a id="Array-valued-abstract-supertypes-1"></a><a class="docs-heading-anchor-permalink" href="#Array-valued-abstract-supertypes" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.AbstractQuantityArray" href="#Alicorn.Quantities.AbstractQuantityArray"><code>Alicorn.Quantities.AbstractQuantityArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractQuantity{T,N} &lt;: AbstractArray{T,N}</code></pre><p>Abstract supertype for all array-valued quantities of dimension <code>N</code> and with elements of type <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.AbstractQuantityVector" href="#Alicorn.Quantities.AbstractQuantityVector"><code>Alicorn.Quantities.AbstractQuantityVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractQuantityVector{T}</code></pre><p>Abstract supertype for one-dimensional array-valued quantities with elements of type <code>T</code>.</p><p>Alias for <code>AbstractQuantityArray{T,1}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.AbstractQuantityMatrix" href="#Alicorn.Quantities.AbstractQuantityMatrix"><code>Alicorn.Quantities.AbstractQuantityMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractQuantityMatrix{T}</code></pre><p>Abstract supertype for two-dimensional array-valued quantities with elements of type <code>T</code>.</p><p>Alias for <code>AbstractQuantityArray{T,2}</code>.</p></div></section></article><h4 id="Array-valued-simple-quantities"><a class="docs-heading-anchor" href="#Array-valued-simple-quantities">Array-valued simple quantities</a><a id="Array-valued-simple-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Array-valued-simple-quantities" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantityArray" href="#Alicorn.Quantities.SimpleQuantityArray"><code>Alicorn.Quantities.SimpleQuantityArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleQuantityArray{T&lt;:Number,N} &lt;: AbstractQuantityArray{T,N}</code></pre><p>A physical quantity consisting of a number array and a physical unit.</p><p>The value field of a <code>SimpleQuantityArray{T,N}</code> is of type <code>Array{T,N}</code>. <code>T</code> needs to be a subtype of <code>Number</code>.</p><p><strong>Fields</strong></p><ul><li><code>value::Array{T,N}</code>: value of the quantity</li><li><code>unit::Unit</code>: unit of the quantity</li></ul><p><strong>Constructors</strong></p><p>``` SimpleQuantityArray(value::AbstractArray{T,N}, abstractUnit::AbstractUnit) where {T&lt;:Number, N} SimpleQuantityArray(value::AbstractArray{T,N}) where {T&lt;:Number, N} SimpleQuantityArray(simpleQuantity::SimpleQuantity) SimpleQuantityArray(sqArray::SimpleQuantityArray)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantityVector" href="#Alicorn.Quantities.SimpleQuantityVector"><code>Alicorn.Quantities.SimpleQuantityVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleQuantityVector{T}</code></pre><p>One-dimensional array-valued simple quantity with elements of type <code>T</code>.</p><p>Alias for <code>SimpleQuantityArray{T,1}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantityMatrix" href="#Alicorn.Quantities.SimpleQuantityMatrix"><code>Alicorn.Quantities.SimpleQuantityMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleQuantityMatrix{T}</code></pre><p>Two-dimensional array-valued simple quantity with elements of type <code>T</code>.</p><p>Alias for <code>SimpleQuantityArray{T,2}</code>.</p></div></section></article><h4 id="Array-valued-quantities"><a class="docs-heading-anchor" href="#Array-valued-quantities">Array-valued quantities</a><a id="Array-valued-quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Array-valued-quantities" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.QuantityArray" href="#Alicorn.Quantities.QuantityArray"><code>Alicorn.Quantities.QuantityArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuantityArray{T&lt;:Number,N} &lt;: AbstractQuantityArray{T,N}</code></pre><p>A physical quantity consisting of an array, a <code>Dimension</code> object representing the physical dimension, and an <code>InternalUnits</code> object representing the units with respect to which the seven basic dimensions of the SI system are measured.</p><p>The value field of a <code>QuantityArray{T,N}</code> is of type <code>Array{T,N}</code>. <code>T</code> needs to be a subtype of <code>Number</code>.</p><p><strong>Fields</strong></p><ul><li><code>value::Array{T,N}</code>: value of the quantity</li><li><code>dimension::Dimension</code>: physical dimension of the quantity</li><li><code>internalUnits::InternalUnits</code>: set of units with respect to which the seven</li></ul><p>basic dimensions of the SI system are measured.</p><p><strong>Constructors</strong></p><p>``` QuantityArray(value::AbstractArray{T,N}, dimension::Dimension, internalUnits::InternalUnits) QuantityArray(sqArray::SimpleQuantityArray, internalUnits::InternalUnits)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.QuantityVector" href="#Alicorn.Quantities.QuantityVector"><code>Alicorn.Quantities.QuantityVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuantityVector{T}</code></pre><p>One-dimensional array-valued quantity with elements of type <code>T</code>.</p><p>Alias for <code>QuantityArray{T,1}</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.QuantityMatrix" href="#Alicorn.Quantities.QuantityMatrix"><code>Alicorn.Quantities.QuantityMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuantityMatrix{T}</code></pre><p>Two-dimensional array-valued quantity with elements of type <code>T</code>.</p><p>Alias for <code>QuantityArray{T,2}</code>.</p></div></section></article><h4 id="Aliases-for-arrays-with-or-without-units"><a class="docs-heading-anchor" href="#Aliases-for-arrays-with-or-without-units">Aliases for arrays with or without units</a><a id="Aliases-for-arrays-with-or-without-units-1"></a><a class="docs-heading-anchor-permalink" href="#Aliases-for-arrays-with-or-without-units" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.VectorQuantity" href="#Alicorn.Quantities.VectorQuantity"><code>Alicorn.Quantities.VectorQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">VectorQuantity{T}</code></pre><p>Type union representing one-dimensional arrays with elements of type <code>T</code>, with or without a physical unit.</p><p>Alias for <code>Union{Vector{T}, AbstractQuantityArray{T, 1}} where T&lt;:Number</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.MatrixQuantity" href="#Alicorn.Quantities.MatrixQuantity"><code>Alicorn.Quantities.MatrixQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MatrixQuantity{T}</code></pre><p>Type union representing two-dimensional arrays with elements of type <code>T</code>, with or without a physical unit.</p><p>Alias for <code>Union{Matrix{T}, AbstractQuantityArray{T, 2}} where T&lt;:Number</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.ArrayQuantity" href="#Alicorn.Quantities.ArrayQuantity"><code>Alicorn.Quantities.ArrayQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ArrayQuantity{T,N}</code></pre><p>Type union representing <code>N</code>-dimensional arrays with elements of type <code>T</code>, with or without a physical unit.</p><p>Alias for <code>Union{Array{T,N}, AbstractQuantityArray{T,N}} where {T&lt;:Number, N}</code>.</p></div></section></article><h3 id="Construction-2"><a class="docs-heading-anchor" href="#Construction-2">Construction</a><a class="docs-heading-anchor-permalink" href="#Construction-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractUnit}} where {T&lt;:Number, N}" href="#Base.:*-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractUnit}} where {T&lt;:Number, N}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(value::AbstractArray{T,N}, abstractUnit::AbstractUnit) where {T&lt;:Number, N}</code></pre><p>Combine the array <code>value</code> and <code>abstractUnit</code> to form a physical quantity of type <code>SimpleQuantityArray</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; [3.5, 4.6] * ucat.tesla
2-element SimpleQuantityVector{Float64} of unit T:
 3.5
 4.6</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractUnit}} where {T&lt;:Number, N}" href="#Base.:/-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractUnit}} where {T&lt;:Number, N}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(value::AbstractArray{T,N}, abstractUnit::AbstractUnit) where {T&lt;:Number, N}</code></pre><p>Combine the array <code>value</code> and <code>abstractUnit</code> to form a physical quantity of type <code>SimpleQuantityArray</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; [3.5, 4.6] / ucat.second
2-element SimpleQuantityVector{Float64} of unit s^-1:
 3.5
 4.6</code></pre></div></section></article><h3 id="Dimension-2"><a class="docs-heading-anchor" href="#Dimension-2">Dimension</a><a class="docs-heading-anchor-permalink" href="#Dimension-2" title="Permalink"></a></h3><h3 id="Unit-conversion-2"><a class="docs-heading-anchor" href="#Unit-conversion-2">Unit conversion</a><a class="docs-heading-anchor-permalink" href="#Unit-conversion-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inUnitsOf-Tuple{AbstractQuantityArray, AbstractUnit}" href="#Alicorn.Quantities.inUnitsOf-Tuple{AbstractQuantityArray, AbstractUnit}"><code>Alicorn.Quantities.inUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inUnitsOf(qArray::AbstractQuantityArray, unit::AbstractUnit)::SimpleQuantityArray</code></pre><p>Express <code>qArray</code> as an object of type <code>SimpleQuantityArray</code> in terms of the unit specified by <code>unit</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>qArray</code> and <code>unit</code> do not agree</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inBasicSIUnits-Tuple{AbstractQuantityArray}" href="#Alicorn.Quantities.inBasicSIUnits-Tuple{AbstractQuantityArray}"><code>Alicorn.Quantities.inBasicSIUnits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inBasicSIUnits(qArray::AbstractQuantity)::SimpleQuantityArray</code></pre><p>Express <code>qArray</code> as an object of type <code>SimpleQuantityArray</code> using the seven basic SI units.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantityArray, AbstractUnit}" href="#Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantityArray, AbstractUnit}"><code>Alicorn.Quantities.valueInUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueInUnitsOf(qArray::AbstractQuantityArray, unit::AbstractUnit)</code></pre><p>Returns the numerical value of <code>qArray</code> expressed in units of <code>unit</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantity</code> and <code>unit</code> do not agree</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantityArray, SimpleQuantity}" href="#Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantityArray, SimpleQuantity}"><code>Alicorn.Quantities.valueInUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueInUnitsOf(quantityArray::AbstractQuantityArray, simpleQuantity::SimpleQuantity)</code></pre><p>Returns the numerical value of <code>quantityArray</code> expressed in units of <code>simpleQuantity</code>.</p><p>The result is equivalent to <code>valueOfDimensionless(quantityArray / simpleQuantity)</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantityArray</code> and <code>simpleQuantity</code> do not agree</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueOfDimensionless-Tuple{AbstractQuantityArray}" href="#Alicorn.Quantities.valueOfDimensionless-Tuple{AbstractQuantityArray}"><code>Alicorn.Quantities.valueOfDimensionless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueOfDimensionless(qArray::AbstractQuantityArray)</code></pre><p>Strips the unit from a dimensionless quantity array and returns its bare value.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>qArray</code> is not dimensionless</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{AbstractQuantityArray, AbstractUnit}" href="#Base.:*-Tuple{AbstractQuantityArray, AbstractUnit}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(qArray::AbstractQuantityArray, unit::AbstractUnit)
Base.:*(unit::AbstractUnit, qArray::AbstractQuantityArray)</code></pre><p>Modify the unit of <code>qArray</code> by multiplying it with <code>unit</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{AbstractQuantityArray, AbstractUnit}" href="#Base.:/-Tuple{AbstractQuantityArray, AbstractUnit}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(qArray::AbstractQuantityArray, unit::AbstractUnit)
Base.:/(unit::AbstractUnit, qArray::AbstractQuantityArray)</code></pre><p>Modify the unit of <code>qArray</code> by dividing it by <code>unit</code>, or vice versa.</p></div></section></article><h3 id="Arithmetics,-elementary-functions-2"><a class="docs-heading-anchor" href="#Arithmetics,-elementary-functions-2">Arithmetics, elementary functions</a><a class="docs-heading-anchor-permalink" href="#Arithmetics,-elementary-functions-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{SimpleQuantityArray, SimpleQuantityArray}" href="#Base.:+-Tuple{SimpleQuantityArray, SimpleQuantityArray}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:+(sqArray1::SimpleQuantityArray, sqArray2::SimpleQuantityArray)</code></pre><p>Add two <code>SimpleQuantityArrays</code>.</p><p>The resulting quantity is expressed in units of <code>sqArray1</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>sqArray1</code> and <code>sqArray2</code> are of different dimensions</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{SimpleQuantityArray, SimpleQuantityArray}" href="#Base.:--Tuple{SimpleQuantityArray, SimpleQuantityArray}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:-(sqArray1::SimpleQuantityArray, sqArray2::SimpleQuantityArray)</code></pre><p>Subtract two <code>SimpleQuantityArrays</code>.</p><p>The resulting quantity is expressed in units of <code>sqArray1</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>sqArray1</code> and <code>sqArray2</code> are of different dimensions</li></ul></div></section></article><h3 id="Numeric-comparison-2"><a class="docs-heading-anchor" href="#Numeric-comparison-2">Numeric comparison</a><a class="docs-heading-anchor-permalink" href="#Numeric-comparison-2" title="Permalink"></a></h3><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{SimpleQuantityArray, SimpleQuantityArray}" href="#Base.:==-Tuple{SimpleQuantityArray, SimpleQuantityArray}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:(==)(sqArray1::SimpleQuantityArray, sqArray2::SimpleQuantityArray)</code></pre><p>Returns <code>true</code> if <code>sqArray1</code> and <code>sqArray2</code> are of equal value and dimension.</p><p>If necessary, <code>sqArray2</code> is expressed in units of <code>sqArray1.unit</code> before the comparison. Note that the conversion oftens lead to rounding errors that render <code>sqArray1</code> not equal <code>sqArray2</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>sqArray1</code> and</li></ul><p><code>sqArray2</code> are not of the same dimension ```</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{QuantityArray, QuantityArray}" href="#Base.:==-Tuple{QuantityArray, QuantityArray}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:(==)(qArray1::QuantityArray, qArray2::QuantityArray)</code></pre><p>Compare two <code>QuantityArray</code> objects.</p><p>The two quantities are equal if their values, their dimensions, and their internal units are equal. Note that the units are not converted during the comparison.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{SimpleQuantityArray, SimpleQuantityArray}" href="#Base.isapprox-Tuple{SimpleQuantityArray, SimpleQuantityArray}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.isapprox(sqArray1::SimpleQuantityArray, sqArray2::SimpleQuantityArray; rtol::Real = sqrt(eps()) )</code></pre><p>Returns <code>isapprox(sqArray1.value, sqArray2.value, rtol=rtol)</code>.</p><p>If necessary, <code>sqArray2</code> is expressed in units of <code>sqArray1.unit</code> before the comparison. Note that the conversion often leads to rounding errors.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>sqArray1</code> and</li></ul><p><code>sqArray2</code> are not of the same dimension</p></div></section></article><h2 id="InternalUnits"><a class="docs-heading-anchor" href="#InternalUnits">InternalUnits</a><a id="InternalUnits-1"></a><a class="docs-heading-anchor-permalink" href="#InternalUnits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.InternalUnits" href="#Alicorn.Quantities.InternalUnits"><code>Alicorn.Quantities.InternalUnits</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InternalUnits</code></pre><p>A set of seven <code>SimpleQuantity</code> objects which represent a choice of units with respect to which the seven basic physical dimensions of the SI system are measured.</p><p><strong>Fields</strong></p><ul><li><code>mass::SimpleQuantity</code>: unit of mass</li><li><code>length::SimpleQuantity</code>: unit of length</li><li><code>time::SimpleQuantity</code>: unit of time</li><li><code>current::SimpleQuantity</code>: unit of current</li><li><code>temperature::SimpleQuantity</code>: unit of temperature</li><li><code>amount::SimpleQuantity</code>: unit of amount</li><li><code>luminousIntensity::SimpleQuantity</code>: unit of luminousIntensity</li></ul><p><strong>Constructors</strong></p><pre><code class="language-none">InternalUnits(::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity)
InternalUnits(; mass = 1*kilogram, length = 1*meter, time = 1*second, current = 1*ampere,temperature = 1*kelvin, amount = 1*mol, luminousIntensity = 1*candela)

# Raises Exceptions
- `Core.DomainError`: if attempting to initialize any field with a quantity
of a value that is zero, infinite, or not real
- `Exceptions.DimensionMismatchError`: if attempting to initialize any field
with a quantity whose dimension does not match the physical dimension the field
represents

# Examples
The following `InternalUnits` measure lengths in units of ``3 cm`` and uses
the basic SI units for all other dimensions:</code></pre><p>jldoctest julia&gt; ucat = UnitCatalogue(); cm = ucat.centi * ucat.meter ;</p><p>julia&gt; InternalUnits(length = 3cm) InternalUnits  mass unit:               1 kg  length unit:             3 cm  time unit:               1 s  current unit:            1 A  temperature unit:        1 K  amount unit:             1 mol  luminous intensity unit: 1 cd ```</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{InternalUnits, InternalUnits}" href="#Base.:==-Tuple{InternalUnits, InternalUnits}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:(==)(internalUnits1::InternalUnits, internalUnits2::InternalUnits)</code></pre><p>Compare two <code>InternalUnits</code> objects.</p><p>Two <code>InternalUnits</code> objects are equal if the <code>SimpleQuantity</code> objects representing the unit for each of the seven physical dimensions are equal.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.internalUnitForDimension-Tuple{Dimension, InternalUnits}" href="#Alicorn.Quantities.internalUnitForDimension-Tuple{Dimension, InternalUnits}"><code>Alicorn.Quantities.internalUnitForDimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">internalUnitForDimension(dimension::Dimension, internalUnits::InternalUnits)</code></pre><p>Returns a <code>SimpleQuantity</code> representing the unit in which quantities of physical dimension <code>dimension</code> are measured according to <code>internalUnits</code>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dimensions/">« Dimensions</a><a class="docs-footer-nextpage" href="../">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 7 October 2021 20:29">Thursday 7 October 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
