<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantities · Alicorn.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img class="docs-light-only" src="../../assets/logo.svg" alt="Alicorn.jl logo"/><img class="docs-dark-only" src="../../assets/logo-dark.svg" alt="Alicorn.jl logo"/></a><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../manual/basic_usage/">Basic Usage</a></li><li><a class="tocitem" href="../../manual/advanced_usage/">Advanced Usage</a></li><li><a class="tocitem" href="../../manual/caveats/">Caveats</a></li></ul></li><li><span class="tocitem">Reference</span><ul><li><a class="tocitem" href="../units/">Units</a></li><li><a class="tocitem" href="../dimensions/">Dimensions</a></li><li class="is-active"><a class="tocitem" href>Quantities</a><ul class="internal"><li><a class="tocitem" href="#Unit-conversion"><span>Unit conversion</span></a></li><li><a class="tocitem" href="#Unit-conversion-2"><span>Unit conversion</span></a></li><li><a class="tocitem" href="#InternalUnits"><span>InternalUnits</span></a></li></ul></li><li><a class="tocitem" href="../">Index</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Reference</a></li><li class="is-active"><a href>Quantities</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Quantities</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com//blob/master/docs/src/reference/quantities.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Quantities"><a class="docs-heading-anchor" href="#Quantities">Quantities</a><a id="Quantities-1"></a><a class="docs-heading-anchor-permalink" href="#Quantities" title="Permalink"></a></h1><p>This section describes the Quantities submodule of Alicorn. The module is concerned with defining and manipulating physical quantities.</p><p>Unless stated otherwise, all types, functions, and constants defined in the submodule are exported by Alicorn.</p><h4 id="Contents"><a class="docs-heading-anchor" href="#Contents">Contents</a><a id="Contents-1"></a><a class="docs-heading-anchor-permalink" href="#Contents" title="Permalink"></a></h4><ul><li><a href="#Quantities">Quantities</a></li><ul><li><a href="#Unit-conversion">Unit conversion</a></li><li><a href="#Unit-conversion-2">Unit conversion</a></li><li><a href="#InternalUnits">InternalUnits</a></li></ul></ul><h4 id="Quantities-2"><a class="docs-heading-anchor" href="#Quantities-2">Quantities</a><a class="docs-heading-anchor-permalink" href="#Quantities-2" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.AbstractQuantity" href="#Alicorn.Quantities.AbstractQuantity"><code>Alicorn.Quantities.AbstractQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractQuantity{T}</code></pre><p>Abstract supertype for all types that represent a scalar physical quantity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantity" href="#Alicorn.Quantities.SimpleQuantity"><code>Alicorn.Quantities.SimpleQuantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleQuantity{T&lt;:Number} &lt;: AbstractQuantity{T}</code></pre><p>A physical quantity consisting of a scalar value and a physical unit.</p><p>The value field of a <code>SimpleQuantity{T}</code> is of type <code>T</code>, which needs to be a subtype of <code>Number</code>.</p><p><strong>Fields</strong></p><ul><li><code>value::T</code>: value of the quantity</li><li><code>unit::Unit</code>: unit of the quantity</li></ul><p><strong>Constructors</strong></p><pre><code class="language-none">SimpleQuantity(value::T, abstractUnit::AbstractUnit) where T &lt;: Number
SimpleQuantity(value::T) where T &lt;: Number
SimpleQuantity(abstractUnit::AbstractUnit)
SimpleQuantity(simpleQuantity::SimpleQuantity)</code></pre><p>If no <code>AbstractUnit</code> is passed to the constructor, the <code>Alicorn.unitlessUnit</code> is used by default. If no value is passed to the constructor, the value is set to 1 by default.</p><p><strong>Examples</strong></p><ol><li><p>The quantity <span>$7\,\mathrm{nm}$</span> (seven nanometers) can be constructed using the constructor method as follows:</p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; nanometer = ucat.nano * ucat.meter
UnitFactor nm

julia&gt; quantity = SimpleQuantity(7, nanometer)
7 nm</code></pre></li><li><p>Alternatively, <span>$7\,\mathrm{nm}$</span> can be constructed arithmetically:</p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; nm = ucat.nano * ucat.meter
UnitFactor nm

julia&gt; quantity = 7nm
7 nm</code></pre></li></ol></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.Quantity" href="#Alicorn.Quantities.Quantity"><code>Alicorn.Quantities.Quantity</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Quantity{T&lt;:Number} &lt;: AbstractQuantity{T}</code></pre><p>A physical quantity consisting of a number, a <code>Dimension</code> object representing the physical dimension, and an <code>InternalUnits</code> object representing the units with respect to which the seven basic dimensions of the SI system are measured.</p><p>The value field of a <code>Quantity{T}</code> is of type <code>T</code>, which needs to be a subtype of <code>Number</code>.</p><p><strong>Fields</strong></p><ul><li><code>value::T</code>: value of the quantity</li><li><code>dimension::Dimension</code>: physical dimension of the quantity</li><li><code>internalUnits::InternalUnits</code>: set of units with respect to which the seven</li></ul><p>basic dimensions of the SI system are measured.</p><p><strong>Constructors</strong></p><pre><code class="language-none">Quantity(value::T, dimension::Dimension, internalUnits::InternalUnits) where T &lt;: Number
Quantity(simpleQuantity::SimpleQuantity, internalUnits::InternalUnits)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{Number, AbstractUnit}" href="#Base.:*-Tuple{Number, AbstractUnit}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(value::Number, abstractUnit::AbstractUnit)</code></pre><p>Combine <code>value</code> and <code>abstractUnit</code> to form a physical quantity of type <code>SimpleQuantity</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; 3.5 * ucat.tesla
3.5 T</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{Number, AbstractUnit}" href="#Base.:/-Tuple{Number, AbstractUnit}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(value::Number, abstractUnit::AbstractUnit)</code></pre><p>Combine <code>value</code> and <code>abstractUnit</code> to form a physical quantity of type <code>SimpleQuantity</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; 3.5 / ucat.second
3.5 s^-1</code></pre></div></section></article><h2 id="Unit-conversion"><a class="docs-heading-anchor" href="#Unit-conversion">Unit conversion</a><a id="Unit-conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-conversion" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inUnitsOf-Tuple{AbstractQuantity, AbstractUnit}" href="#Alicorn.Quantities.inUnitsOf-Tuple{AbstractQuantity, AbstractUnit}"><code>Alicorn.Quantities.inUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inUnitsOf(quantity::AbstractQuantity, unit::AbstractUnit)::SimpleQuantity</code></pre><p>Express <code>quantity</code> as an object of type <code>SimpleQuantity</code> in terms of the unit specified by <code>unit</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantity</code> and <code>unit</code> do not agree</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inBasicSIUnits-Tuple{AbstractQuantity}" href="#Alicorn.Quantities.inBasicSIUnits-Tuple{AbstractQuantity}"><code>Alicorn.Quantities.inBasicSIUnits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inBasicSIUnits(quantity::AbstractQuantity)::SimpleQuantity</code></pre><p>Express <code>quantity</code> as an object of type <code>SimpleQuantity</code> using the seven basic SI units.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantity, AbstractUnit}" href="#Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantity, AbstractUnit}"><code>Alicorn.Quantities.valueInUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueInUnitsOf(quantity::AbstractQuantity, unit::AbstractUnit)</code></pre><p>Returns the numerical value of <code>quantity</code> expressed in units of <code>unit</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantity</code> and <code>unit</code> do not agree</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantity, SimpleQuantity}" href="#Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantity, SimpleQuantity}"><code>Alicorn.Quantities.valueInUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueInUnitsOf(quantity::AbstractQuantity, simpleQuantity::SimpleQuantity)</code></pre><p>Returns the numerical value of <code>quantity</code> expressed in units of <code>simpleQuantity</code>.</p><p>The result is equivalent to <code>valueOfDimensionless(quantity / simpleQuantity)</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantity</code> and <code>simpleQuantity</code> do not agree</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueOfDimensionless-Tuple{AbstractQuantity}" href="#Alicorn.Quantities.valueOfDimensionless-Tuple{AbstractQuantity}"><code>Alicorn.Quantities.valueOfDimensionless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueOfDimensionless(quantity::AbstractQuantity)</code></pre><p>Strips the unit from a dimensionless quantity and returns its bare value.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>quantity</code> is not dimensionless</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{AbstractQuantity, AbstractUnit}" href="#Base.:*-Tuple{AbstractQuantity, AbstractUnit}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(quantity::AbstractQuantity, unit::AbstractUnit)
Base.:*(unit::AbstractUnit, quantity::AbstractQuantity)</code></pre><p>Modify the unit of <code>quantity</code> by multiplying it with <code>unit</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{AbstractQuantity, AbstractUnit}" href="#Base.:/-Tuple{AbstractQuantity, AbstractUnit}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(quantity::AbstractQuantity, unit::AbstractUnit)
Base.:/(unit::AbstractUnit, quantity::AbstractQuantity)</code></pre><p>Modify the unit of <code>quantity</code> by dividing it by <code>unit</code>, or vice versa.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueOfDimensionless-Tuple{SimpleQuantity}" href="#Alicorn.Quantities.valueOfDimensionless-Tuple{SimpleQuantity}"><code>Alicorn.Quantities.valueOfDimensionless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueOfDimensionless(quantity::AbstractQuantity)</code></pre><p>Strips the unit from a dimensionless quantity and returns its bare value.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>quantity</code> is not dimensionless</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{SimpleQuantity, SimpleQuantity}" href="#Base.:==-Tuple{SimpleQuantity, SimpleQuantity}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:(==)(simpleQuantity1::SimpleQuantity, simpleQuantity2::SimpleQuantity)</code></pre><p>Returns <code>true</code> if <code>simpleQuantity1</code> and <code>simpleQuantity2</code> are of equal value.</p><p>If necessary, <code>simpleQuantity2</code> is expressed in units of <code>simpleQuantity1.unit</code> before the comparison. Note that the conversion oftens lead to rounding errors that render <code>simpleQuantity1</code> not equal <code>simpleQuantity2</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>simpleQuantity1</code> and</li></ul><p><code>simpleQuantity2</code> are not of the same dimension</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; q1 = 7 * ucat.meter
7 m

julia&gt; q2 = 700 * (ucat.centi * ucat.meter)
700 cm

julia&gt; q1 == q1
true

julia&gt; q1 == q2
true</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{Quantity, Quantity}" href="#Base.:==-Tuple{Quantity, Quantity}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:(==)(quantity1::Quantity, quantity2::Quantity)</code></pre><p>Compare two <code>Quantity</code> objects.</p><p>The two quantities are equal if their values, their dimensions, and their internal units are equal. Note that the units are not converted during the comparison.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{SimpleQuantity, SimpleQuantity}" href="#Base.:+-Tuple{SimpleQuantity, SimpleQuantity}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:+(simpleQuantity1::SimpleQuantity, simpleQuantity2::SimpleQuantity)</code></pre><p>Add two SimpleQuantities.</p><p>The resulting quantity is expressed in units of <code>simpleQuantity1</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>simpleQuantity1</code> and <code>simpleQuantity2</code> are of different dimensions</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{SimpleQuantity, SimpleQuantity}" href="#Base.:--Tuple{SimpleQuantity, SimpleQuantity}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:-(simpleQuantity1::SimpleQuantity, simpleQuantity2::SimpleQuantity)</code></pre><p>Subtract two SimpleQuantities.</p><p>The resulting quantity is expressed in units of <code>simpleQuantity1</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>simpleQuantity1</code> and <code>simpleQuantity2</code> are of different dimensions</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isless-Tuple{SimpleQuantity, SimpleQuantity}" href="#Base.isless-Tuple{SimpleQuantity, SimpleQuantity}"><code>Base.isless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.isless(simpleQuantity1::SimpleQuantity, simpleQuantity2::SimpleQuantity)</code></pre><p>Returns <code>true</code> if <code>simpleQuantity1</code> is of lesser value than <code>simpleQuantity2</code>.</p><p>If necessary, <code>simpleQuantity2</code> is expressed in units of <code>simpleQuantity1.unit</code> before the comparison. Note that the conversion often leads to rounding errors.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>simpleQuantity1</code> and</li></ul><p><code>simpleQuantity2</code> are not of the same dimension</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{SimpleQuantity, SimpleQuantity}" href="#Base.isapprox-Tuple{SimpleQuantity, SimpleQuantity}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.isapprox(simpleQuantity1::SimpleQuantity, simpleQuantity2::SimpleQuantity; rtol::Real = sqrt(eps()) )</code></pre><p>Returns <code>isapprox(simpleQuantity1.value, simpleQuantity2.value, rtol=rtol)</code>.</p><p>If necessary, <code>simpleQuantity2</code> is expressed in units of <code>simpleQuantity1.unit</code> before the comparison. Note that the conversion often leads to rounding errors.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>simpleQuantity1</code> and</li></ul><p><code>simpleQuantity2</code> are not of the same dimension</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.zero-Tuple{Type, AbstractUnit}" href="#Base.zero-Tuple{Type, AbstractUnit}"><code>Base.zero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.zero(numberType::Type, unit::AbstractUnit)</code></pre><p>Return a <code>SimpleQuantity</code> with unit <code>unit</code> and value <code>zero(numberType)</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.DomainError</code>: if <code>numberType</code> is not a subtype of <code>Number</code>.</li></ul></div></section></article><h4 id="Quantity-Arrays"><a class="docs-heading-anchor" href="#Quantity-Arrays">Quantity Arrays</a><a id="Quantity-Arrays-1"></a><a class="docs-heading-anchor-permalink" href="#Quantity-Arrays" title="Permalink"></a></h4><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.AbstractQuantityArray" href="#Alicorn.Quantities.AbstractQuantityArray"><code>Alicorn.Quantities.AbstractQuantityArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractQuantity{T,N} &lt;: AbstractArray{T,N}</code></pre><p>Abstract supertype for all types that represent a physical quantity array.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.SimpleQuantityArray" href="#Alicorn.Quantities.SimpleQuantityArray"><code>Alicorn.Quantities.SimpleQuantityArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SimpleQuantityArray{T&lt;:Number,N} &lt;: AbstractQuantityArray{T,N}</code></pre><p>A physical quantity consisting of a number array and a physical unit.</p><p>The value field of a <code>SimpleQuantityArray{T,N}</code> is of type <code>Array{T,N}</code>. <code>T</code> needs to be a subtype of <code>Number</code>.</p><p><strong>Fields</strong></p><ul><li><code>value::Array{T,N}</code>: value of the quantity</li><li><code>unit::Unit</code>: unit of the quantity</li></ul><p><strong>Constructors</strong></p><p>``` SimpleQuantityArray(value::AbstractArray{T,N}, abstractUnit::AbstractUnit) where {T&lt;:Number, N} SimpleQuantityArray(value::AbstractArray{T,N}) where {T&lt;:Number, N} SimpleQuantityArray(simpleQuantity::SimpleQuantity) SimpleQuantityArray(sqArray::SimpleQuantityArray)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.QuantityArray" href="#Alicorn.Quantities.QuantityArray"><code>Alicorn.Quantities.QuantityArray</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QuantityArray{T&lt;:Number,N} &lt;: AbstractQuantityArray{T,N}</code></pre><p>A physical quantity consisting of an array, a <code>Dimension</code> object representing the physical dimension, and an <code>InternalUnits</code> object representing the units with respect to which the seven basic dimensions of the SI system are measured.</p><p>The value field of a <code>QuantityArray{T,N}</code> is of type <code>Array{T,N}</code>. <code>T</code> needs to be a subtype of <code>Number</code>.</p><p><strong>Fields</strong></p><ul><li><code>value::Array{T,N}</code>: value of the quantity</li><li><code>dimension::Dimension</code>: physical dimension of the quantity</li><li><code>internalUnits::InternalUnits</code>: set of units with respect to which the seven</li></ul><p>basic dimensions of the SI system are measured.</p><p><strong>Constructors</strong></p><p>``` QuantityArray(value::AbstractArray{T,N}, dimension::Dimension, internalUnits::InternalUnits) QuantityArray(sqArray::SimpleQuantityArray, internalUnits::InternalUnits)</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractUnit}} where {T&lt;:Number, N}" href="#Base.:*-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractUnit}} where {T&lt;:Number, N}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(value::AbstractArray{T,N}, abstractUnit::AbstractUnit) where {T&lt;:Number, N}</code></pre><p>Combine the array <code>value</code> and <code>abstractUnit</code> to form a physical quantity of type <code>SimpleQuantityArray</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; [3.5, 4.6] * ucat.tesla
2-element SimpleQuantityVector{Float64} of unit T:
 3.5
 4.6</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractUnit}} where {T&lt;:Number, N}" href="#Base.:/-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, AbstractUnit}} where {T&lt;:Number, N}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(value::AbstractArray{T,N}, abstractUnit::AbstractUnit) where {T&lt;:Number, N}</code></pre><p>Combine the array <code>value</code> and <code>abstractUnit</code> to form a physical quantity of type <code>SimpleQuantityArray</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; ucat = UnitCatalogue() ;

julia&gt; [3.5, 4.6] / ucat.second
2-element SimpleQuantityVector{Float64} of unit s^-1:
 3.5
 4.6</code></pre></div></section></article><h2 id="Unit-conversion-2"><a class="docs-heading-anchor" href="#Unit-conversion-2">Unit conversion</a><a class="docs-heading-anchor-permalink" href="#Unit-conversion-2" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inUnitsOf-Tuple{AbstractQuantityArray, AbstractUnit}" href="#Alicorn.Quantities.inUnitsOf-Tuple{AbstractQuantityArray, AbstractUnit}"><code>Alicorn.Quantities.inUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inUnitsOf(qArray::AbstractQuantityArray, unit::AbstractUnit)::SimpleQuantityArray</code></pre><p>Express <code>qArray</code> as an object of type <code>SimpleQuantityArray</code> in terms of the unit specified by <code>unit</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>qArray</code> and <code>unit</code> do not agree</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.inBasicSIUnits-Tuple{AbstractQuantityArray}" href="#Alicorn.Quantities.inBasicSIUnits-Tuple{AbstractQuantityArray}"><code>Alicorn.Quantities.inBasicSIUnits</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inBasicSIUnits(qArray::AbstractQuantity)::SimpleQuantityArray</code></pre><p>Express <code>qArray</code> as an object of type <code>SimpleQuantityArray</code> using the seven basic SI units.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantityArray, AbstractUnit}" href="#Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantityArray, AbstractUnit}"><code>Alicorn.Quantities.valueInUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueInUnitsOf(qArray::AbstractQuantityArray, unit::AbstractUnit)</code></pre><p>Returns the numerical value of <code>qArray</code> expressed in units of <code>unit</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantity</code> and <code>unit</code> do not agree</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantityArray, SimpleQuantity}" href="#Alicorn.Quantities.valueInUnitsOf-Tuple{AbstractQuantityArray, SimpleQuantity}"><code>Alicorn.Quantities.valueInUnitsOf</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueInUnitsOf(quantityArray::AbstractQuantityArray, simpleQuantity::SimpleQuantity)</code></pre><p>Returns the numerical value of <code>quantityArray</code> expressed in units of <code>simpleQuantity</code>.</p><p>The result is equivalent to <code>valueOfDimensionless(quantityArray / simpleQuantity)</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if the dimensions of <code>quantityArray</code> and <code>simpleQuantity</code> do not agree</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.valueOfDimensionless-Tuple{AbstractQuantityArray}" href="#Alicorn.Quantities.valueOfDimensionless-Tuple{AbstractQuantityArray}"><code>Alicorn.Quantities.valueOfDimensionless</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">valueOfDimensionless(qArray::AbstractQuantityArray)</code></pre><p>Strips the unit from a dimensionless quantity array and returns its bare value.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>qArray</code> is not dimensionless</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:*-Tuple{AbstractQuantityArray, AbstractUnit}" href="#Base.:*-Tuple{AbstractQuantityArray, AbstractUnit}"><code>Base.:*</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:*(qArray::AbstractQuantityArray, unit::AbstractUnit)
Base.:*(unit::AbstractUnit, qArray::AbstractQuantityArray)</code></pre><p>Modify the unit of <code>qArray</code> by multiplying it with <code>unit</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:/-Tuple{AbstractQuantityArray, AbstractUnit}" href="#Base.:/-Tuple{AbstractQuantityArray, AbstractUnit}"><code>Base.:/</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:/(qArray::AbstractQuantityArray, unit::AbstractUnit)
Base.:/(unit::AbstractUnit, qArray::AbstractQuantityArray)</code></pre><p>Modify the unit of <code>qArray</code> by dividing it by <code>unit</code>, or vice versa.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{SimpleQuantityArray, SimpleQuantityArray}" href="#Base.:==-Tuple{SimpleQuantityArray, SimpleQuantityArray}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:(==)(sqArray1::SimpleQuantityArray, sqArray2::SimpleQuantityArray)</code></pre><p>Returns <code>true</code> if <code>sqArray1</code> and <code>sqArray2</code> are of equal value and dimension.</p><p>If necessary, <code>sqArray2</code> is expressed in units of <code>sqArray1.unit</code> before the comparison. Note that the conversion oftens lead to rounding errors that render <code>sqArray1</code> not equal <code>sqArray2</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>sqArray1</code> and</li></ul><p><code>sqArray2</code> are not of the same dimension ```</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{QuantityArray, QuantityArray}" href="#Base.:==-Tuple{QuantityArray, QuantityArray}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:(==)(qArray1::QuantityArray, qArray2::QuantityArray)</code></pre><p>Compare two <code>QuantityArray</code> objects.</p><p>The two quantities are equal if their values, their dimensions, and their internal units are equal. Note that the units are not converted during the comparison.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{SimpleQuantityArray, SimpleQuantityArray}" href="#Base.isapprox-Tuple{SimpleQuantityArray, SimpleQuantityArray}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.isapprox(sqArray1::SimpleQuantityArray, sqArray2::SimpleQuantityArray; rtol::Real = sqrt(eps()) )</code></pre><p>Returns <code>isapprox(sqArray1.value, sqArray2.value, rtol=rtol)</code>.</p><p>If necessary, <code>sqArray2</code> is expressed in units of <code>sqArray1.unit</code> before the comparison. Note that the conversion often leads to rounding errors.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>sqArray1</code> and</li></ul><p><code>sqArray2</code> are not of the same dimension</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:+-Tuple{SimpleQuantityArray, SimpleQuantityArray}" href="#Base.:+-Tuple{SimpleQuantityArray, SimpleQuantityArray}"><code>Base.:+</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:+(sqArray1::SimpleQuantityArray, sqArray2::SimpleQuantityArray)</code></pre><p>Add two <code>SimpleQuantityArrays</code>.</p><p>The resulting quantity is expressed in units of <code>sqArray1</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>sqArray1</code> and <code>sqArray2</code> are of different dimensions</li></ul></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:--Tuple{SimpleQuantityArray, SimpleQuantityArray}" href="#Base.:--Tuple{SimpleQuantityArray, SimpleQuantityArray}"><code>Base.:-</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:-(sqArray1::SimpleQuantityArray, sqArray2::SimpleQuantityArray)</code></pre><p>Subtract two <code>SimpleQuantityArrays</code>.</p><p>The resulting quantity is expressed in units of <code>sqArray1</code>.</p><p><strong>Raises Exceptions</strong></p><ul><li><code>Alicorn.Exceptions.DimensionMismatchError</code>: if <code>sqArray1</code> and <code>sqArray2</code> are of different dimensions</li></ul></div></section></article><h2 id="InternalUnits"><a class="docs-heading-anchor" href="#InternalUnits">InternalUnits</a><a id="InternalUnits-1"></a><a class="docs-heading-anchor-permalink" href="#InternalUnits" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.InternalUnits" href="#Alicorn.Quantities.InternalUnits"><code>Alicorn.Quantities.InternalUnits</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">InternalUnits</code></pre><p>A set of seven <code>SimpleQuantity</code> objects which represent a choice of units with respect to which the seven basic physical dimensions of the SI system are measured.</p><p><strong>Fields</strong></p><ul><li><code>mass::SimpleQuantity</code>: unit of mass</li><li><code>length::SimpleQuantity</code>: unit of length</li><li><code>time::SimpleQuantity</code>: unit of time</li><li><code>current::SimpleQuantity</code>: unit of current</li><li><code>temperature::SimpleQuantity</code>: unit of temperature</li><li><code>amount::SimpleQuantity</code>: unit of amount</li><li><code>luminousIntensity::SimpleQuantity</code>: unit of luminousIntensity</li></ul><p><strong>Constructors</strong></p><pre><code class="language-none">InternalUnits(::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity, ::SimpleQuantity)
InternalUnits(; mass = 1*kilogram, length = 1*meter, time = 1*second, current = 1*ampere,temperature = 1*kelvin, amount = 1*mol, luminousIntensity = 1*candela)

# Raises Exceptions
- `Core.DomainError`: if attempting to initialize any field with a quantity
of a value that is zero, infinite, or not real
- `Exceptions.DimensionMismatchError`: if attempting to initialize any field
with a quantity whose dimension does not match the physical dimension the field
represents

# Examples
The following `InternalUnits` measure lengths in units of ``3 cm`` and uses
the basic SI units for all other dimensions:</code></pre><p>jldoctest julia&gt; ucat = UnitCatalogue(); cm = ucat.centi * ucat.meter ;</p><p>julia&gt; InternalUnits(length = 3cm) InternalUnits  mass unit:               1 kg  length unit:             3 cm  time unit:               1 s  current unit:            1 A  temperature unit:        1 K  amount unit:             1 mol  luminous intensity unit: 1 cd ```</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.:==-Tuple{InternalUnits, InternalUnits}" href="#Base.:==-Tuple{InternalUnits, InternalUnits}"><code>Base.:==</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">Base.:(==)(internalUnits1::InternalUnits, internalUnits2::InternalUnits)</code></pre><p>Compare two <code>InternalUnits</code> objects.</p><p>Two <code>InternalUnits</code> objects are equal if the <code>SimpleQuantity</code> objects representing the unit for each of the seven physical dimensions are equal.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Alicorn.Quantities.internalUnitForDimension-Tuple{Dimension, InternalUnits}" href="#Alicorn.Quantities.internalUnitForDimension-Tuple{Dimension, InternalUnits}"><code>Alicorn.Quantities.internalUnitForDimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">internalUnitForDimension(dimension::Dimension, internalUnits::InternalUnits)</code></pre><p>Returns a <code>SimpleQuantity</code> representing the unit in which quantities of physical dimension <code>dimension</code> are measured according to <code>internalUnits</code>.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../dimensions/">« Dimensions</a><a class="docs-footer-nextpage" href="../">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 4 October 2021 23:09">Monday 4 October 2021</span>. Using Julia version 1.6.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
